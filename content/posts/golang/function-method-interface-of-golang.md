+++
title = "Function-Method-Interface-of-Golang"
date = 2022-09-09T15:22:58+08:00
draft = true
author = 'vdong'
categories = ['技术']
tags = ['golang']

+++

Go 语言中方法分为 具名和匿名，当匿名函数引用了外部变量时候就成了闭包函数。

方法是绑定到一个具体类型的特殊函数，方法依托类型。必须在编译时静态绑定。

接口定义了方法的集合，这些方法依托于运行时的对象（实现了接口中的方法），因此接口对应的方法是运行时动态绑定的。

Go 语言程序的初始化和执行化总是从 `main.main` 开始。如果 `main` 导入了其他包，则按顺序将他们包含进来，一直递归；包含时，先创建和初始化包的常量、变量，然后调用包中的 `init` 函数。如下：

![image-20220909154914868](/imgs/function-method-interface-of-golang/image-20220909154914868.png)

要注意的是，在 `main.main` 函数执行之前所有代码都运行在同一个 `Goroutine` 中，也是运行在程序的主系统线程中。如果某个 `init` 函数内部用 go 关键字启动了新的 `Goroutine` 的话，新的 `Goroutine` 和 `main.main` 函数是并发执行的。

## 函数

Go 语言中函数可以有**多个**返回值。

**参数**和**返回值**都是以**值**的形式和被调用者交换数据的。

函数支持**可变数量**的参数，可变数量的参数必须是最后一个。可变数量的参数其实是一个切片类型的参数。

```go
func Swap(a,b int) (int, int){
    return b,a
}

func Sum(a int, more ...int) int{
    for _,v :=range more{
        a += v
    }
    return a
}
```

函数的返回值也可以用名字：

```go
func Find(m map[int]int, key int) (value int, ok bool) {
    value, ok = m[key]
    return 
}
```

`derfer` 可以在 `reurn` 之后修改返回值：

```go
func Inc() (v int) {
    defer func(){ v++ } ()
    return 42
}
```

 Go 语言中，函数传参是**传值**，只是针对了数据结构中固定部分传值。如：字符串或切片传参时，只是复制了对应数据结构中的指针、字符串长度、切片容量等值，并不包含指针指向的内容。可以将字符串和切片类型的参数转换为 `reflect.StringHeader ` `reflect.SliceHeader`的结构体，可以更好的理解传值的含义：

```go
func twice(x []int){
    for i := range x{
        x[i] *= 2
    }
}

type IntSliceHeader struct {
    Data []int
    Len int
    Cap int
}

func twice(x IntSliceHeader){
    for i:= 0; i<x.Len; i++{
        x.Data[i] *= 2
    }
}
```

如上，切片中的**底层数组部分**是通过**隐式指针传递**(**指针**本身依然是**传值**的，但是指针指向的却是同一份的内存数据)，所以被调用函数是可以通过**修改指针指向的数据**（指针本身的指向并没有发生变化），从而达到修改掉调用参数切片中数据的效果。

Go 语言支持递归调用，且调用深度逻辑上没有限制，函数调用栈不会出现溢出错误，这是因为 Go 语言运行时会根据需要动态调整函数栈的大小。栈最大可达到GB级。

Go 1.4 之前，动态栈采用的时分段式的动态栈，通俗说就是采用一个链表实现动态栈。链表节点位置不变，缺点: 跨节点地址位置不是一定是连续的，CPU缓存命中率低。

Go 1.4 之后改用连续的动态栈实现，通俗来说是采用一个类似动态数组来实现栈。缺点：当连续栈需要动态增长时候，需要重新分配内存空间并复制数据到新的空间，这导致了栈中之前变量的地址发生变化（Go 的运行时会自动更新这些变化）。但是这意味着 ，Go 语言中的指针不是固定不变的，不能随意将指针保存在数值变量中，不能将 Go 语言的地址随意保存到非 GC 的环境中（如：使用 CGO 时，C 语言不能长期持有 Go 与语言的地址）。

Go 语言隐藏了堆栈的细节，编译器和运行时帮我们做了还多工作，以下代码在 C/C++ 中不可行的，但在 Go 语言中并没问题：

```go
// 如果参数变量在栈上的话，函数返回之后栈变量就失效了，返回的地址自然也应该失效了
func f(x int) *int {
    return &x
}

// 内部虽然调用 new 函数创建了 *int 类型的指针对象，但是依然不知道它具体保存在哪里
func g() int {
    x := new(int)
    return *x
}
```

需要注意的是：不要假设变量在内存中的位置是固定不变的，指针随时可能会变化，特别是在你不期望它变化的时候。

## 方法

Go 语言方法关联到结构体上，在编译阶段完成静态绑定。

