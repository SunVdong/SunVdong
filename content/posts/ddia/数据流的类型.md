+++
title = "数据流的类型"
date = 2023-09-07T10:59:06+08:00
draft = true
author = 'vdong'
categories = ['技术']
tags = ['数据密集', '数据流','dataflow']

+++

数据在不共享内存的进程传递，就需要编码为字节序列。有多种方式。

**兼容性** 实际描述了 **编码数据的进程** 和 **解码数据的进程** 之间的关系。它对 **可演化性**（允许你升级系统的部分，而不必全部升级） 非常重要。

数据可以通过多种方式从一个流程流向另一个流程（通常先编码为字节序列，再解码）。谁编码，谁解码？以下是常见场景：

- 数据库
- 服务调用
- 异步消息传递

## 数据库中的数据流

写入数据 ---> 编码数据；读取数据 --- > 解码数据。

单进程连接数据库，现在写入的数据，未来才读取。**向后兼容** 是必须的。

多个进程更常见，可能是不同的应用程序或服务连接一个数据库，也可能是一个服务的几个实例（并行运行，并行的目的是可伸缩性和容错性）。在这个场景下，可能发生，一个数据库中的值被较新的代码写入，被旧代码读取。因此 数据库也需要 **向前兼容**。

当你向数据库新增了一个字段（即修改了数据库的表结构，或者说修改了数据的模式 schema ），较新的代码写入包含新字段内容的数据到数据库中，旧代码（不知道有新字段）在读取、更新、写回记录到数据库时，理想状态时需保值新字段的值不变。编码格式需要支持，在应用层面也需要小心。

### 数据的生命周期超出代码的生命周期

代码的版本更新频繁，数据库的数据版本可能变化可能大多并不频繁。

将数据迁移到一个新的模式是昂贵的，大多数数据库尽可能避免它，大多数关系数据库（除了mysql，并非真的必要时，它也经常会重写整个表）允许一些简单的模式变更，如添加一个默认为空的新列，而非重写现有数据。 LinkedIn 的文档数据库 Espresso 使用 Avro 存储，允许它使用 Avro 的模式演变规则。

模式演变允许整个数据库看起来好像是用单个模式编码的，即使底层存储可能包含用各种历史版本的模式编码的记录。

### 数据归档

创建数据快照时，即使源数据库中的原始编码包含来自不同时代的模式版本的混合，数据转储通常也将使用最新模式进行编码。既然你不管怎样都要拷贝数据，那么你可以对这个数据拷贝进行一致的编码。

由于数据转储是一次写入的，而且以后是不可变的，所以 Avro 对象容器文件等格式非常适合。这也是一个很好的机会，可以将数据编码为面向分析的列式格式，例如 Parquet。

## 服务中的数据流：REST 与 RPC

