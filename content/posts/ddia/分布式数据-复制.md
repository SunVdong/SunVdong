+++
title = "分布式数据-复制"
date = 2024-04-15T18:00:06+08:00
draft = true
author = 'vdong'
categories = ['生活', '技术']
tags = ['日常', '折腾']
typora-root-url = "..\\..\\..\\static"

+++

复制的原因：

- 使数据和用户在地理位置上更近（降低延迟）
- 使系统即使一部分故障，也能正常工作（提高可用性）
- 伸缩可接受读请求的机器数量（提高读取吞吐量）

复制的困难：在于处理数据的变更。变更复制算法：**单主（singer leader ，单领导者）**，**多主（multi leader，多领导者）**，**无主（leaderless ，无领队者）**。

复制时需要权衡的问题：1. 同步还是异步？2. 如何处理失败的副本？...

## 领导者和追随者

存储了数据库拷贝的每个节点被称为 **副本（replica）**。

每一次向数据库的写入操作都需要传播到所有副本上，否则副本就会包含不一样的数据。解决方案：基于领导者的复制，主从。原理：

1. 其中一个副本被指定为 **领导者（leader）**，也称为 **主库（master|primary）** 。当客户端要向数据库写入时，它必须将请求发送给该 **领导者**，其会将新数据写入其本地存储。
2. 其他副本被称为 **追随者（followers）**，亦称为 **只读副本（read replicas）**、**从库（slaves）**、**备库（ secondaries）** 或 **热备（hot-standby）**。每当领导者将新数据写入本地存储时，它也会将数据变更发送给所有的追随者，称之为 **复制日志（replication log）** 或 **变更流（change stream）**。每个跟随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照与领导者相同的处理顺序来进行所有写入。
3. 当客户想要从数据库中读取数据时，它可以向领导者或任一追随者进行查询。但只有领导者才能接受写入操作（从客户端的角度来看从库都是只读的）。

这种复制模式是很多关系型数据库的内置功能，也被用于一些非关系数据库（如：MongoDB、RethinkDB 和 Espresso），甚至它不仅限于数据库：Kafka、RabbitMQ 等分布式消息代理也使用它。某些网络文件系统，如 DRBD 这样的块复制设备也类似。

## 同步复制or异步复制

![img](/imgs/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE-%E5%A4%8D%E5%88%B6/fig5-2.png)

Follower1 是同步复制，主库等待从库确认后，才向用户报告写入成功。

Follower2 是异步复制，主库不等待从库的响应。

通常从库的复制是很快的：大多数数据库能在不到1秒中完成同步。但是，这是没有保证的。有些情况从库可能落后主库几分钟，如：从库正在从失败中恢复；系统正在最大负载附近工作；或者节点间的网络问题。

同步复制的优点：副本被保障拥有领导者最新且一致的数据，当领导者挂了，副本可以直接上。缺点：如果从库（crash 或者网络问题等）没有响应，主库就无法处理写入操作。

因此，将所有从库都设置为同步的是不切实际的：任何一个节点的中断都会导致整个系统停滞不前。实际上，如果在数据库上启用同步复制，通常意味着其中 **一个** 从库是同步的，而其他的从库则是异步的。如果该同步从库变得不可用或缓慢，则将一个异步从库改为同步运行。这保证你至少在两个节点上拥有最新的数据副本：主库和同步从库。 这种配置有时也被称为 **半同步（semi-synchronous）**。

异步复制缺点：主库失效且不可恢复，未复制给从库的写入将丢失。优点：即使所有从库都落后了，主库也可以继续处理写入。弱的持久化。

### 设置新从库

数据不断变化，简单复制是不行的（复制过程中也可能有数据变化），如果先锁定数据库再复制，违背了高可用性的目标，所以复制过程通常如下：

1. 在某个时刻获取主库一致性快照。如：mysql 的 innobackupex 和 XtraBackup。
2. 将快照复制到新的从库节点。
3. 从库连接主库，拉取快照之后发生的数据变更。前提要求是快照和主库复制日志中位置精确对应。这个位置有不同的名称，如 PostgreSQL 中叫 **日志序列号（log sequence nubmer，LSN）**， MySQL 中叫 **二进制日志坐标（binlog coordinates）**。
4. 当从库处理完快照之后积累的数据变更，从库 **赶上（caught up）**了主库。

