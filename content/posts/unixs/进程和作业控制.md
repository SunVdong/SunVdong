+++
title = "进程和作业控制"
date = 2022-05-07T09:15:46+08:00
draft = false
author = 'vdong'
categories = ['技术']
tags = ['折腾']

+++

Unix中，每个对象或者由文件表示，或者由进程表示。简单来讲，文件就是一个输出源或者输出目标。进程是一个正在运行的程序。文件提供对数据的访问，而进程使事件发生。

进程来源何处？系统如何管理自己的进程？如何控制自己的进程？

## 内核管理进程的方式

精确讲，**进程**是一个加载到内存中准备运行的程序，再加上程序所需的数据，以及跟踪管理程序状态所需要的各种信息。

所有进程由内核管理。

当进程创建时，内核赋予其一个唯一标识号，叫做**进程ID**或 **PID** 。为了跟踪管理系统中的所有进程，内核维护一个**进程表（process table）**。按照 **PID** 索引，每个进程在进程表中有一个条目。除了 **PID** ，每个条目还包含有描述和管理进程所需的信息。

进程共享系统的资源：处理器、内存、I/O设备、网络连接等。为了管理这样一个复杂的工作负荷，内核提供了一个复杂的调度服务，即 **调度器（scheduler）**。

调度器一直维护这一个所有正在等待执行的进程的列表。通过复杂的算法，调度器每次选择一个进程，给予这个进程在一个短暂的事件间隔（称为时间片）中运行的机会（多处理器系统中，调度器每次可以选择多个进程）。

时间片又称 **CPU时间**。通常是10毫秒（千分之十秒）的 **CPU** 时间。一旦时间片用尽，该进程就返回调度列表，由内核启动另一个进程。

### 进程分叉到死亡

进程是如何创建的呢？

内核为进程提供基本服务：

- 内存管理（虚拟内存管理，包括分页）
- 进程管理（进程创建、终止、调度）
- 进程间通信（本地、网络）
- 输入、输出（通过设备驱动程序，即与物理设备实际通信的程序）
- 文件管理
- 安全和访问控制
- 网络访问（如 TCP、IP）

当进程需要内核执行服务时，它就使用**系统调用**发送请求。最重要的系统调用就是那些用户进程控制和 I/O 的系统调用。

| 系统调用 | 目的                                                         |
| -------- | ------------------------------------------------------------ |
| fork     | 创建当前进程的一个副本（原始进程称为 **父进程（parent process）**，新进程和父进程一模一样，称为 **子进程（child process）**） |
| wait     | 等待另一个进程结束执行                                       |
| exec     | 在当前进程中执行一个新的程序                                 |
| exit     | 终止当前进程                                                 |
| kill     | 向另一个进程发送一个信号                                     |
| open     | 打开一个用户读取或写入的文件                                 |
| read     | 从文件中读取数据                                             |
| write    | 向文件中写入数据                                             |
| close    | 关闭文件                                                     |

显示当前 shell 的 PID：`echo $$`

命令有两种类型：内部命令和外部命令。内部命令直接由shell解释不创建新进程。外部命令需要shell运行一个单独的程序。

1. shell 使用 fork 系统调用创建一个全新的进程。

   1. 子进程使用 exec 系统调用将它自身从运行 shell 的进程变成运行外部程序的进程；
   2. 父进程使用 wait 系统调用暂停，直到子进程执行结束。

2. 外部程序结束，子进程使用 exit 系统调用停止自身。称为进程 **死亡（die）** 或 **终止(terminate)**。故意停止一个进程，称为 **杀死（kill）**。

   1. 进程死亡时，进程所使用的资源（内存、文件等）都被释放，从而可以被其他进程使用。

   2. 子进程已死但仍然没有被回收称为 **僵进程（zombie）**，尽管僵进程已经死了，进程表里仍然保存这自己的条目，这是因为该条目包含着，最近死亡的子进程的数据，而父进程可能对这些数据感兴趣。

      > 在[类UNIX系统](https://zh.wikipedia.org/wiki/类UNIX系统)中，**僵尸进程**是指完成执行（通过`exit`[系统调用](https://zh.wikipedia.org/wiki/系统调用)，或运行时发生[致命错误](https://zh.wikipedia.org/wiki/致命错误)或收到终止[信号](https://zh.wikipedia.org/wiki/信号_(计算机科学))所致），但在操作系统的进程表中仍然存在其[进程控制块](https://zh.wikipedia.org/wiki/进程控制块)，处于"[终止状态](https://zh.wikipedia.org/w/index.php?title=终止状态&action=edit&redlink=1)"的进程。这发生于[子进程](https://zh.wikipedia.org/wiki/子进程)需要保留表项以允许其[父进程](https://zh.wikipedia.org/wiki/父进程)读取子进程的[退出状态](https://zh.wikipedia.org/wiki/退出状态)：一旦退出态通过`wait`[系统调用](https://zh.wikipedia.org/wiki/系统调用)读取，僵尸进程条目就从进程表中删除，称之为"回收"（reaped）。正常情况下，进程直接被其父进程`wait`并由系统回收。进程长时间保持僵尸状态一般是错误的并导致[资源泄漏](https://zh.wikipedia.org/wiki/资源泄漏)。

3. 父进程一直在等待子进程的死亡，当子进程成为僵进程之后，立即被内核唤醒。

   1. 现在父进程有机会查看进程表中的僵进程条目，看看发生了什么结果。
   2. 然后内核将进程表中的僵进程条目移除。

### 孤儿进程和废弃进程

1. 当父进程分叉后，意外死亡 ，只剩下子进程，会发生什么？

​		子进程继续执行，称为 **孤儿** 进程。孤儿进程完成工作死亡时，没有父进程被唤醒，以僵进程的形式存在。

​		现代操作系统，孤儿进程将自动被 #1 进程 （init进程）收养，孤儿进程死亡时，init 进程充当父进程，快速清理僵进程。

2. 父进程创建子进程，但是没有等待进程死亡？（仅当程序有 bug ，允许程序创建子进程而不等待子进程死亡）

   情况1. 父进程死亡，形成孤儿进程如上。

   情况2. 子进程死亡时，子进程就称为了僵进程（没有父进程读取子进程的退出状态，导致进程表的条目无法被回收）。

   ​	如果程序以偶然的方式创建了一个僵进程，那么将没有办法清除这个进程（kill 对僵进程无效），毕竟无法杀死已经死掉的东西。

   ​	为了清除成为僵进程的废弃子进程，可以使用 kill 程序终止父进程，父进程死亡，僵进程就成为孤儿进程，从而自动被init进程收养。适当的时候，init 进程将履行继父的职责，清除僵尸进程的参与信息。  

### 区分父进程和子进程

fork 两个相同的进程，父进程和子进程。如果两个进程相同，那么父进程怎么直到它是父进程，子进程如何知道他是子进程呢？

当 fork 系统调用结束它的工作时，它向父进程和子进程各传递一个数值，这个数值成为返回值。子进程返回值是 0，父进程的返回值是新创建的进程的的进程 ID。

### 第一个进程：init

如果进程是使用 fork 创建，那么每个子进程必须有一个父进程。那么在某个地方必然存在第一个进程。

在引导过程的末尾，内核 “手动” 创建一个特殊的进程，不是通过fork。这个进程的 PID 是 0。称为 **空闲进程（idle process）**。

在执行了一些重要的功能（例如 初始化内核所需要的数据结构）之后，空闲进程进行分叉，创建#1号进程。然后空闲进程执行一个非常简单的程序，本质是一个无穷的循环，不做任何事情（因此这个进程被命名为空闲进程）。这里的思想是，每当没有进程等待执行时，调度器就运行空闲进程。

进程#1执行设置内核以及结束引导过程所需的剩余步骤。因此称它为 **初始化进程（init process）**，具体而言，初始化进程，打开系统控制台，挂载根文件系统，运行包含在文件/etc/inittab 中的脚本。在这一过程中，init 多次fork，创建运行系统所需的基本进程（如，运行级别设置），并允许用户登录，在这一过程中，init 成为系统中所有其他进程的祖先。

与 空闲进程（#0） 进程不同，初始化进程 （#1） 进程永远不会停止。且是进程表中的第一个进程，一直存在进程表中，直到系统关闭。

> Linux系统在引导时加载[Linux内核](https://zh.wikipedia.org/wiki/Linux內核)后，便由Linux内核加载init程序，由init程序完成余下的引导过程，比如加载[执行级别](https://zh.wikipedia.org/w/index.php?title=執行級別&action=edit&redlink=1)，加载服务，启动Shell/图形化界面等等。-- 维基百科

### 前台进程与后台进程

在命令的末尾键入一个 `&` 字符，可以将前台进程转换成后台进程。

- 前台进程: shell 在提示用户输入新命令之前等待当前程序结束，这样的进程。
- 后台进程：shell 启动一个程序，但又让该程序自己运行，这样的进程。

大多数unix程序从标准输入（stdin）读取输入，将输出写到标准输出（stdout），错误消息则写入标准错误（stderr）。stdin 相连 键盘，stdout 和 stderr 相连显示器。我们可以重定向 stdin、 stdout 和 stderr。

当后台程序试图从标准 I/O读取并写到标准 I/O时，会发生什么？

1. 后台运行的程序试图从 stdin 读取数据，但是stdin 什么都没有，进程将无限期的暂停，等待输入。（可通过`fg` 命令，将其移动至前台）
2. 后台运行的程序向 stdout 和 stderr 写入数据时，将显示在显示器上。 
