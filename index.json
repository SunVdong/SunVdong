[{"categories":["技术"],"content":" 配置本机可以接收远端的syslog日志根据需要启用udp或tcp模块，并设置端口，使其能够接收消息。 # vim /etc/rsyslog.conf $ModLoad imudp $UDPServerRun 514 重启 rsyslog 服务 systemctl restart rsyslog 防火墙放行端口 iptables -A INPUT -p udp --dport 514 -j ACCEPT 监听放行的端口 # -l listen -p source-port -4 ipv4 -u udp nc -l -p 514 -4 -u 在远端的主机上发送日志测试 logger \"hello logs\" --server {{hostname}} --port 514 以上监听将会显示类似如下信息： \u003c5\u003eSep 15 15:36:00 root: hello logs ","date":"2022-09-15","objectID":"/posts/unixs/rsyslog-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97/:1:0","series":null,"tags":["unix","linux","syslog"],"title":" rsyslog 发送和接收远程日志","uri":"/posts/unixs/rsyslog-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97/#配置本机可以接收远端的syslog日志"},{"categories":["技术"],"content":" 配置本机将syslog日志发送远端修改配置文件 # 旧版本语法 # An on-disk queue is created for this action. If the remote host is # down, messages are spooled to disk and sent when it is up again. #$ActionQueueFileName fwdRule1 # unique name prefix for spool files #$ActionQueueMaxDiskSpace 1g # 1gb space limit (use as much as possible) #$ActionQueueSaveOnShutdown on # save messages to disk on shutdown #$ActionQueueType LinkedList # run asynchronously #$ActionResumeRetryCount -1 # infinite retries if host is down # Facility.Severity *.* 表示所有 @表示传输协议（@表示udp，@@表示tcp），后面是ip和端口。 *.* @@remote-host:514 # 新版本语法 *.* action(type=\"omfwd\" target=\"192.0.2.1\" port=\"10514\" protocol=\"tcp\") *.* action(type=\"omfwd\" #使用 omfwd udp 和 tcp 转发插件 queue.type=\"LinkedList\" # 启用 LinkedList 内存队列，queue_type 可以是 direct、linkedlist 或者 fixedarray（它们是内存队列）或者磁盘 action.resumeRetryCount=\"-1\" # 远程主机关闭时重试次数 -1 无限次 queue.size=\"10000\" # 内存中队列的数量，非字节大小，防止峰值 queue.saveonshutdown=\"on\" # 本地主机关闭时，是否保存内存中的队列到磁盘 target=\"10.43.138.1\" Port=\"10514\" Protocol=\"tcp\") 重启 rsyslog 服务 systemctl restart rsyslog 对于 rsyslog 你也可以定义一个配置文件，重新启动一个新的进程。 rsyslogd -i /var/run/rsyslog_reindexer.pid -f /home/me/rsyslog_reindexer.conf 参考： 如何使用 tcp 和 udp 端口将 syslog 日志发送到远程服务器上 syslog 详解和配置 使用 rsyslog 重排 es 数据 rsys文档 man 手册 ","date":"2022-09-15","objectID":"/posts/unixs/rsyslog-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97/:2:0","series":null,"tags":["unix","linux","syslog"],"title":" rsyslog 发送和接收远程日志","uri":"/posts/unixs/rsyslog-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97/#配置本机将syslog日志发送远端"},{"categories":["技术"],"content":" 数组","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:1:0","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#数组"},{"categories":["技术"],"content":" 定义方式var a[3] int var b = [...]int{1, 2, 3} var c = [...]int{2:3, 1:2} // 长度为3 {0,2,3} // 混合以上方式 var d = [...]int{1,2,4:5,6} // {1, 2, 0, 0, 5, 6} Go 语言中数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如 C 语言的数组），而是一个完整的值。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。 ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:1:1","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#定义方式"},{"categories":["技术"],"content":" 循环// 数组元素大小为 0 ， 所以没有内存占用 var times [5][0]int for range times { fmt.Println(\"aaa\") } ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:1:2","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#循环"},{"categories":["技术"],"content":" 多种数组// 函数数组 图像解码器 var decoder1 [2]func(io.Reader) (image.Image, error) var decoder2 = [...]func (io.Reader) (image.Image,error) { png.Decode, jpeg.Decode, } // 接口数组 var unknown1 [2]interface {} var unknown2 = [...]interface {}{ 123 , \"你好\" } // 管道数组 var chanlist = [2]chan int{} ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:1:3","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#多种数组"},{"categories":["技术"],"content":" 空数组长度为 0 的数组部占用空间。可用于强调某种特有的类型。如管道的同步操作 c1 := make(chan [0]int) go func() { fmt.Println(\"c1\") c1 \u003c- [0]int{} }() \u003c-c1 我们并不关心管道中传输数据的真实类型，其中管道接收和发送操作只是用于消息的同步。对于这种场景，我们用空数组来作为管道类型可以减少管道元素赋值时的开销。当然一般更倾向于用无类型的匿名结构体代替： c2 := make(chan struct{}) go func(){ fmt.Println(\"c2\") c2 \u003c- struct{}{} // struct{} 部分是类型， {} 表示对应结构体的值 }() \u003c-c2 ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:1:4","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#空数组"},{"categories":["技术"],"content":" 字符串字符串是一个不可改变的字节序列。go 源码要求 UTF8 编码。所以源码中的字符串字面量通常被解释为 UTF8编码的 unicode rune 序列。 ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:2:0","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#字符串"},{"categories":["技术"],"content":" 切片切片是一种简化版的动态数组。 x := []int{2, 3, 5, 7, 11} y := x[1:3] // output: [2 3 5 7 11] len(x): 5 cap(x): 5 fmt.Println(x, \" len(x):\", len(x), \" cap(x):\", cap(x)) // output: [3 5] len(y): 2 cap(y): 4 fmt.Println(y, \" len(y):\", len(y), \" cap(y):\", cap(y)) ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:3:0","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#切片"},{"categories":["技术"],"content":" 定义方式var ( a []int // nil 切片, 和 nil 相等, 一般用来表示一个不存在的切片 b = []int{} // 空切片, 和 nil 不相等, 一般用来表示一个空的集合 c = []int{1, 2, 3} // 有 3 个元素的切片, len 和 cap 都为 3 d = c[:2] // 有 2 个元素的切片, len 为 2, cap 为 3 , [0,2) e = c[0:2:cap(c)] // 有 2 个元素的切片, len 为 2, cap 为 3 , [0,2) 且指定 cap 为 c 的 cap f = c[:0] // 有 0 个元素的切片, len 为 0, cap 为 3 g = make([]int, 3) // 有 3 个元素的切片, len 和 cap 都为 3 h = make([]int, 2, 3) // 有 2 个元素的切片, len 为 2, cap 为 3 i = make([]int, 0, 3) // 有 0 个元素的切片, len 为 0, cap 为 3 ) ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:3:1","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#定义方式-1"},{"categories":["技术"],"content":" 添加切片元素var a []int a = append(a, 1) // 追加 1 个元素 a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式 a = append(a, []int{1,2,3}...) // 追加 1 个切片, 切片需要解包 当容量不足时，append 会重新分配内存，导致巨大的内存分配和复制数据开销。 头部追加元素 var a = []int{1,2,3} a = append([]int{0}, a...) a = append([]int{-3,-2,-1}, a...) 中间插入元素 var a []int a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第 i 个位置插入 x a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第 i 个位置插入切片 // 以上会创建中间的临时切片，使用 copy 和 append 会避免 a = append(a, 0) // 切片扩展 1 个空间 copy(a[i+1:], a[i:]) // a[i:] 向后移动 1 个位置 a[i] = x // 设置新添加的元素 a = append(a, x...) // 为 x 切片扩展足够的空间 copy(a[i+len(x):], a[i:]) // a[i:] 向后移动 len(x) 个位置 copy(a[i:], x) // 复制新添加的切片 ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:3:2","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#添加切片元素"},{"categories":["技术"],"content":" 删除切片元素尾部删除 a = []int{1,2,3} a = a[:len(a)-1] // 删除尾部一个元素 a = a[:len(a)-n] // 删除尾部n个元素 删除开头 a = []int{1, 2, 3} a = a[1:] // 删除开头 1 个元素 a = a[N:] // 删除开头 N 个元素 a = []int{1, 2, 3} a = append(a[:0], a[1:]...) // 删除开头 1 个元素 a = append(a[:0], a[N:]...) // 删除开头 N 个元素 a = []int{1, 2, 3} a = a[:copy(a, a[1:])] // 删除开头 1 个元素 a = a[:copy(a, a[N:])] // 删除开头 N 个元素 删除中间 a = []int{1, 2, 3, ...} a = append(a[:i], a[i+1:]...) // 删除中间 1 个元素 a = append(a[:i], a[i+N:]...) // 删除中间 N 个元素 a = a[:i+copy(a[i:], a[i+1:])] // 删除中间 1 个元素 a = a[:i+copy(a[i:], a[i+N:])] // 删除中间 N 个元素 ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:3:3","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#删除切片元素"},{"categories":["技术"],"content":" 切片内存技巧len 为 0 且 cap 不为 0 的切片非常有用，可以降低内存分配的次数。 func TrimSpace(s []byte) []byte { b := s[:0] for _, x := range s { if x != ' ' { b = append(b, x) } } return b } func Filter(s []byte, fn func(x byte) bool) []byte { b := s[:0] for _, x := range s { if !fn(x) { b = append(b, x) } } return b } ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:3:4","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#切片内存技巧"},{"categories":["技术"],"content":" 避免内存泄漏切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。 例如，FindPhoneNumber 函数加载整个文件到内存，然后搜索第一个出现的电话号码，最后结果以切片方式返回。 func FindPhoneNumber(filename string) []byte { b, _ := ioutil.ReadFile(filename) return regexp.MustCompile(\"[0-9]+\").Find(b) } 这段代码返回的 []byte 指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。一个小的需求可能导致需要长时间保存整个文件数据。这虽然这并不是传统意义上的内存泄漏，但是可能会拖慢系统的整体性能。 要修复这个问题，可以将感兴趣的数据复制到一个新的切片中（数据的传值是 Go 语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖）： func FindPhoneNumber(filename string) []byte { b, _ := ioutil.ReadFile(filename) b = regexp.MustCompile(\"[0-9]+\").Find(b) return append([]byte{}, b...) } 指向指针的切片也可能遇到类似的问题： var a []*int{ ... } a = a[:len(a)-1] // 被删除的最后一个元素依然被引用, 可能导致 GC 操作被阻碍 var a []*int{ ... } a[len(a)-1] = nil // GC 回收最后一个元素内存 a = a[:len(a)-1] // 从切片删除最后一个元素 此为《go 语言高级编程》 读书笔记 ","date":"2022-09-09","objectID":"/posts/golang/array-string-slice-of-golang/:3:5","series":null,"tags":["golang"],"title":"Golang 中的数组字符串和切片","uri":"/posts/golang/array-string-slice-of-golang/#避免内存泄漏"},{"categories":["生活"],"content":" 好奇心是什么好奇心是 【我不知道】：我不知道接下来会经历什么，但我愿意尝试。 好奇心是【我允许】：尝试的过程中，一些意外状况是正常现象，我允许自己做不好。 好奇心是【我不着急】：我不着急立刻得出结论，而是多观察一阵子再说。 真正的好奇心，意味着 【对新经验的开放】。 暂停实验室 ","date":"2022-06-13","objectID":"/posts/mess/%E5%A5%BD%E5%A5%87%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88/:1:0","series":null,"tags":["日常","人间清醒"],"title":"好奇心是什么","uri":"/posts/mess/%E5%A5%BD%E5%A5%87%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88/#好奇心是什么"},{"categories":["技术"],"content":" scp 多个主机并填写密码#!/usr/bin/expect set filename [lindex $argv 0] set dir_path [lindex $argv 1] set IP_NOS_1 \"192.168.122.11\" set IP_NOS_2 \"192.168.122.12\" set IP_NOS_3 \"192.168.122.13\" set IP_NOS_4 \"192.168.122.14\" set IP_NOS_5 \"192.168.122.15\" set username \"root\" set passwd \"root\" set timeout 200 if { $argc!=2 } { puts \"WARNING ! srcipt needs two parameter !\" puts \" Usage: (parameter 1: filename) filename you want to transfer\" puts \" Usage: (parameter 2: path) path you want to save to where.\" puts \"this scripts will cp file into 5 kvm!\" exit 0 } for {set i 1} {$i \u003c 6} {incr i} { switch $i { 1 {set ip $IP_NOS_1} 3 {set ip $IP_NOS_3} 4 {set ip $IP_NOS_4} 5 {set ip $IP_NOS_5} } puts \"#---------------------copy file to kvm$i------------------#\" spawn scp ./$filename $username@$ip:$dir_path expect { \"(yes/no)?\" { send \"yes\"; exp_continue } \"assword:\" { send \"$passwd\\r\" } } expect \"100%\" sleep 1 } ","date":"2022-06-01","objectID":"/posts/unixs/expect%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/:1:0","series":null,"tags":["linux","unix","脚本"],"title":"expect-自动交互脚本","uri":"/posts/unixs/expect%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/#scp-多个主机并填写密码"},{"categories":["技术"],"content":" 参考网站expect范例 expect安装 ","date":"2022-06-01","objectID":"/posts/unixs/expect%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/:2:0","series":null,"tags":["linux","unix","脚本"],"title":"expect-自动交互脚本","uri":"/posts/unixs/expect%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/#参考网站"},{"categories":["技术"],"content":"Unix中，每个对象或者由文件表示，或者由进程表示。简单来讲，文件就是一个输出源或者输出目标。进程是一个正在运行的程序。文件提供对数据的访问，而进程使事件发生。 进程来源何处？系统如何管理自己的进程？如何控制自己的进程？ ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:0:0","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#"},{"categories":["技术"],"content":" 内核管理进程的方式精确讲，进程是一个加载到内存中准备运行的程序，再加上程序所需的数据，以及跟踪管理程序状态所需要的各种信息。 所有进程由内核管理。 当进程创建时，内核赋予其一个唯一标识号，叫做进程ID或 PID 。为了跟踪管理系统中的所有进程，内核维护一个进程表（process table）。按照 PID 索引，每个进程在进程表中有一个条目。除了 PID ，每个条目还包含有描述和管理进程所需的信息。 进程共享系统的资源：处理器、内存、I/O设备、网络连接等。为了管理这样一个复杂的工作负荷，内核提供了一个复杂的调度服务，即 调度器（scheduler）。 调度器一直维护这一个所有正在等待执行的进程的列表。通过复杂的算法，调度器每次选择一个进程，给予这个进程在一个短暂的事件间隔（称为时间片）中运行的机会（多处理器系统中，调度器每次可以选择多个进程）。 时间片又称 CPU时间。通常是10毫秒（千分之十秒）的 CPU 时间。一旦时间片用尽，该进程就返回调度列表，由内核启动另一个进程。 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:1:0","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#内核管理进程的方式"},{"categories":["技术"],"content":" 进程分叉到死亡进程是如何创建的呢？ 内核为进程提供基本服务： 内存管理（虚拟内存管理，包括分页） 进程管理（进程创建、终止、调度） 进程间通信（本地、网络） 输入、输出（通过设备驱动程序，即与物理设备实际通信的程序） 文件管理 安全和访问控制 网络访问（如 TCP、IP） 当进程需要内核执行服务时，它就使用系统调用发送请求。最重要的系统调用就是那些用户进程控制和 I/O 的系统调用。 系统调用 目的 fork 创建当前进程的一个副本（原始进程称为 父进程（parent process），新进程和父进程一模一样，称为 子进程（child process）） wait 等待另一个进程结束执行 exec 在当前进程中执行一个新的程序 exit 终止当前进程 kill 向另一个进程发送一个信号 open 打开一个用户读取或写入的文件 read 从文件中读取数据 write 向文件中写入数据 close 关闭文件 显示当前 shell 的 PID：echo $$ 命令有两种类型：内部命令和外部命令。内部命令直接由shell解释不创建新进程。外部命令需要shell运行一个单独的程序。 shell 使用 fork 系统调用创建一个全新的进程。 子进程使用 exec 系统调用将它自身从运行 shell 的进程变成运行外部程序的进程； 父进程使用 wait 系统调用暂停，直到子进程执行结束。 外部程序结束，子进程使用 exit 系统调用停止自身。称为进程 死亡（die） 或 终止(terminate)。故意停止一个进程，称为 杀死（kill）。 进程死亡时，进程所使用的资源（内存、文件等）都被释放，从而可以被其他进程使用。 子进程已死但仍然没有被回收称为 僵进程（zombie），尽管僵进程已经死了，进程表里仍然保存这自己的条目，这是因为该条目包含着，最近死亡的子进程的数据，而父进程可能对这些数据感兴趣。 在类UNIX系统中，僵尸进程是指完成执行（通过exit系统调用，或运行时发生致命错误或收到终止信号所致），但在操作系统的进程表中仍然存在其进程控制块，处于\"终止状态“的进程。这发生于子进程需要保留表项以允许其父进程读取子进程的退出状态：一旦退出态通过wait系统调用读取，僵尸进程条目就从进程表中删除，称之为\"回收”（reaped）。正常情况下，进程直接被其父进程wait并由系统回收。进程长时间保持僵尸状态一般是错误的并导致资源泄漏。 父进程一直在等待子进程的死亡，当子进程成为僵进程之后，立即被内核唤醒。 现在父进程有机会查看进程表中的僵进程条目，看看发生了什么结果。 然后内核将进程表中的僵进程条目移除。 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:1:1","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#进程分叉到死亡"},{"categories":["技术"],"content":" 孤儿进程和废弃进程 当父进程分叉后，意外死亡 ，只剩下子进程，会发生什么？ ​ 子进程继续执行，称为 孤儿 进程。孤儿进程完成工作死亡时，没有父进程被唤醒，以僵进程的形式存在。 ​ 现代操作系统，孤儿进程将自动被 #1 进程 （init进程）收养，孤儿进程死亡时，init 进程充当父进程，快速清理僵进程。 父进程创建子进程，但是没有等待进程死亡？（仅当程序有 bug ，允许程序创建子进程而不等待子进程死亡） 情况1. 父进程死亡，形成孤儿进程如上。 情况2. 子进程死亡时，子进程就称为了僵进程（没有父进程读取子进程的退出状态，导致进程表的条目无法被回收）。 ​ 如果程序以偶然的方式创建了一个僵进程，那么将没有办法清除这个进程（kill 对僵进程无效），毕竟无法杀死已经死掉的东西。 ​ 为了清除成为僵进程的废弃子进程，可以使用 kill 程序终止父进程，父进程死亡，僵进程就成为孤儿进程，从而自动被init进程收养。适当的时候，init 进程将履行继父的职责，清除僵尸进程的参与信息。 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:1:2","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#孤儿进程和废弃进程"},{"categories":["技术"],"content":" 区分父进程和子进程fork 两个相同的进程，父进程和子进程。如果两个进程相同，那么父进程怎么直到它是父进程，子进程如何知道他是子进程呢？ 当 fork 系统调用结束它的工作时，它向父进程和子进程各传递一个数值，这个数值成为返回值。子进程返回值是 0，父进程的返回值是新创建的进程的的进程 ID。 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:1:3","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#区分父进程和子进程"},{"categories":["技术"],"content":" 第一个进程：init如果进程是使用 fork 创建，那么每个子进程必须有一个父进程。那么在某个地方必然存在第一个进程。 在引导过程的末尾，内核 “手动” 创建一个特殊的进程，不是通过fork。这个进程的 PID 是 0。称为 空闲进程（idle process）。 在执行了一些重要的功能（例如 初始化内核所需要的数据结构）之后，空闲进程进行分叉，创建#1号进程。然后空闲进程执行一个非常简单的程序，本质是一个无穷的循环，不做任何事情（因此这个进程被命名为空闲进程）。这里的思想是，每当没有进程等待执行时，调度器就运行空闲进程。 进程#1执行设置内核以及结束引导过程所需的剩余步骤。因此称它为 初始化进程（init process），具体而言，初始化进程，打开系统控制台，挂载根文件系统，运行包含在文件/etc/inittab 中的脚本。在这一过程中，init 多次fork，创建运行系统所需的基本进程（如，运行级别设置），并允许用户登录，在这一过程中，init 成为系统中所有其他进程的祖先。 与 空闲进程（#0） 进程不同，初始化进程 （#1） 进程永远不会停止。且是进程表中的第一个进程，一直存在进程表中，直到系统关闭。 Linux系统在引导时加载Linux内核后，便由Linux内核加载init程序，由init程序完成余下的引导过程，比如加载执行级别，加载服务，启动Shell/图形化界面等等。– 维基百科 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:1:4","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#第一个进程init"},{"categories":["技术"],"content":" 前台进程与后台进程在命令的末尾键入一个 \u0026 字符，可以将前台进程转换成后台进程 (也叫 异步进程（asynchronous process）)。 前台进程: shell 在提示用户输入新命令之前等待当前程序结束，这样的进程。 后台进程：shell 启动一个程序，但又让该程序自己运行，这样的进程。 大多数unix程序从标准输入（stdin）读取输入，将输出写到标准输出（stdout），错误消息则写入标准错误（stderr）。stdin 相连 键盘，stdout 和 stderr 相连显示器。我们可以重定向 stdin、 stdout 和 stderr。如果用户想要在进程自己结束之前终止进程，可以按 ^C 发送 intr 信号，或者 ^\\ 发送 quit 信号，区别是 quit 信号会生成一个供调试使用的磁芯转存。 异步进程 默认情况下标准输入与空文件 dev/null 相连，也不响应 intr 和 quit 信号。 当后台程序试图从标准 I/O读取并写到标准 I/O时，会发生什么？ 后台运行的程序试图从 stdin 读取数据，但是stdin 什么都没有，进程将无限期的暂停，等待输入。（可通过fg 命令，将其移动至前台） 后台运行的程序向 stdout 和 stderr 写入数据时，将显示在显示器上。 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:2:0","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#前台进程与后台进程"},{"categories":["技术"],"content":" 作业控制作业控制使多个进程同时运行成为可能：一个进程在前台运行，其他进程在后台运行。 作业的本质是将每条输入的命令视为一个作业，该作业由一个唯一的作业号（job number）标识。 作业控制命令 jobs 显示作业列表 ps 显示进程列表 fg 将作业移动至前台 bg 将作业移动至后台 supend 挂起当前 shell ^Z 挂起当前前台作业 kill 向作业发送信号，默认情况下，终止作业 变量 echo $$ 显示当前 shell 的 PID echo $! 显示上一条移至后台的命令的 PID 终端设置 stty tostop 挂起试图向终端写数据的后台作业 stty -tostop 关闭 tostop shell 选项：Bash 、Korn shell set -o monitor 允许作业控制 set +o nomonitor 关闭 monitor set -o notify 当后台作业结束时，立即通报 set +o nonotify 关闭 notify 作业和进程的区别 进程是正在执行或者准备执行的程序，作业指解释整个命令行所需的全部进程。 进程内核控制的，作业 shell 控制的。 内核使用进程表记录进程，shell 使用 **作业表（job table）**记录作业。 # 1个进程；1个作业 date # 4个进程；1个作业 who | cut -c 1-8 | sort | uniq -c date; who; uptime; cal 12 2008 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:2:1","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#作业控制"},{"categories":["技术"],"content":" 前后台运行示例 作业结束通知显示时机# 后台运行作业 ls \u003e temp \u0026 # 此时会输出 [作业ID] 进程ID [1] 4003 # 如果一个作业由多个程序构成的话 显示最后一个程序的进程ID who | cut -c 1-8 | sort |uniq -c \u0026 # 会输出 4356 是 uniq 的进程ID [2] 4356 # 当后台作业结束时，shell 不会立即通知您，以防止干扰您正在做的事情。 # shell 会一直等待，直到要显示下一个 shell 提示时显示，如下 [1] Done ls \u003e temp # 强制作业结束时，立即通知您 set -o notify # 恢复默认设置 set +o notify # C-Shell 家族 分别对应 set notify unset notify 挂起作业任何时候作业有三种状态：前台运行；后台运行；暂停，等待信号恢复。 暂停前台作业，可以按 ^Z 键(Ctrl-Z)，即发送 susp 信号。我们称将进程**挂起（suspend）**或进程 停止（stop）（实际是临时中止，可以重新启动）。永久停止必须 ^C 键或 kill 命令。 恢复挂起的程序，使用 fg 命令。 # eg： 挂起 vim 然后查看 cal 说明书，然后再返回 vim vi a.txt ^Z # 挂起vim man cal fg # 返回vim 挂起作业时，进程会无限期停止。如果试图注销系统，shell 会得到一条警告，你可以 fg 将挂起的作业移动到前台，并正确的退出程序，或者第二次注销系统（可能会丢失数据）。 # eg： 挂起shell # 切换 root 用户 su - # 做一些工作 ... # 挂起root用户的 shell,有密码需 -f 强制挂起 suspend -f # 做一些工作... # 回到root的shell fg ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:2:2","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#前后台运行示例"},{"categories":["技术"],"content":" 前后台运行示例 作业结束通知显示时机# 后台运行作业 ls \u003e temp \u0026 # 此时会输出 [作业ID] 进程ID [1] 4003 # 如果一个作业由多个程序构成的话 显示最后一个程序的进程ID who | cut -c 1-8 | sort |uniq -c \u0026 # 会输出 4356 是 uniq 的进程ID [2] 4356 # 当后台作业结束时，shell 不会立即通知您，以防止干扰您正在做的事情。 # shell 会一直等待，直到要显示下一个 shell 提示时显示，如下 [1] Done ls \u003e temp # 强制作业结束时，立即通知您 set -o notify # 恢复默认设置 set +o notify # C-Shell 家族 分别对应 set notify unset notify 挂起作业任何时候作业有三种状态：前台运行；后台运行；暂停，等待信号恢复。 暂停前台作业，可以按 ^Z 键(Ctrl-Z)，即发送 susp 信号。我们称将进程**挂起（suspend）**或进程 停止（stop）（实际是临时中止，可以重新启动）。永久停止必须 ^C 键或 kill 命令。 恢复挂起的程序，使用 fg 命令。 # eg： 挂起 vim 然后查看 cal 说明书，然后再返回 vim vi a.txt ^Z # 挂起vim man cal fg # 返回vim 挂起作业时，进程会无限期停止。如果试图注销系统，shell 会得到一条警告，你可以 fg 将挂起的作业移动到前台，并正确的退出程序，或者第二次注销系统（可能会丢失数据）。 # eg： 挂起shell # 切换 root 用户 su - # 做一些工作 ... # 挂起root用户的 shell,有密码需 -f 强制挂起 suspend -f # 做一些工作... # 回到root的shell fg ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:2:2","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#作业结束通知显示时机"},{"categories":["技术"],"content":" 前后台运行示例 作业结束通知显示时机# 后台运行作业 ls \u003e temp \u0026 # 此时会输出 [作业ID] 进程ID [1] 4003 # 如果一个作业由多个程序构成的话 显示最后一个程序的进程ID who | cut -c 1-8 | sort |uniq -c \u0026 # 会输出 4356 是 uniq 的进程ID [2] 4356 # 当后台作业结束时，shell 不会立即通知您，以防止干扰您正在做的事情。 # shell 会一直等待，直到要显示下一个 shell 提示时显示，如下 [1] Done ls \u003e temp # 强制作业结束时，立即通知您 set -o notify # 恢复默认设置 set +o notify # C-Shell 家族 分别对应 set notify unset notify 挂起作业任何时候作业有三种状态：前台运行；后台运行；暂停，等待信号恢复。 暂停前台作业，可以按 ^Z 键(Ctrl-Z)，即发送 susp 信号。我们称将进程**挂起（suspend）**或进程 停止（stop）（实际是临时中止，可以重新启动）。永久停止必须 ^C 键或 kill 命令。 恢复挂起的程序，使用 fg 命令。 # eg： 挂起 vim 然后查看 cal 说明书，然后再返回 vim vi a.txt ^Z # 挂起vim man cal fg # 返回vim 挂起作业时，进程会无限期停止。如果试图注销系统，shell 会得到一条警告，你可以 fg 将挂起的作业移动到前台，并正确的退出程序，或者第二次注销系统（可能会丢失数据）。 # eg： 挂起shell # 切换 root 用户 su - # 做一些工作 ... # 挂起root用户的 shell,有密码需 -f 强制挂起 suspend -f # 做一些工作... # 回到root的shell fg ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:2:2","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#挂起作业"},{"categories":["技术"],"content":" 显示作业列表# -l 会显示进程号 jobs [-l] # 将作业移动至前台 fg %[job] %[job] # 将作业移动至后台 bg [%job...] 作业号 含义 %% 当前作业 %+ 当前作业 %- 前一个作业 %n 作业#n %name 含有指定命令名的作业 %?name 命令中任意位置含有name的作业 ps: 当准备后台运行程序，但是输入命令时忘记键入 \u0026 字符，只需按下 ^Z 挂起作业，然后使用 bg 命令将作业移动至后台。 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:2:3","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#显示作业列表"},{"categories":["技术"],"content":" ps 程序的使用ps 难用的原因是20世纪80年代，unix 分支：官方 Unix（AT\u0026T公司）、非官方（加利福尼亚大学伯克利分校）。UNIX 选项 和 BSD 选项。 unix 选项以连字符 - 开头，BSD 选项没有连字符。 # unix 选项 ps [-aefFly] [-p pid] [-u userid] # BSD ps [ajluvx] [p pid] [U userid] UNIX 选项 显示哪些进程？ ps 与您用户标识和终端相关的进程 ps -a 与任何用户标识和终端相关的进程 ps -e 所有进程（包含守护进程） ps -p pid 与指定进程 ID pid 相关的进程 ps -u userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TTY TIME CMD ps -f UID PID PPID C TTY TIME CMD ps -F UID PID PPID C SZ RSS STIME TTY TIME CMD ps -l F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD ps -ly S UID PID PPID C PRI NI RSS SZ WCHAN TTY TIME CMD 有用的特殊组合 ps 显示自己的进程 ps -ef 显示所有用户进程，完整给输出 ps -a 显示所有非守护进程的 进程 ps -t - （仅显示所有守护进程） 数据列说明： UNIX 标题 含义 ADDR 进程表中的 虚拟地址 C 处理器利用率（废弃率） CMD 正在执行的命令名 F 与进程相关的标识 NI nice 值，用于设置优先级 PID 进程 ID PPID 父进程 ID PRI 优先级（较大的数字：优先级低） RSS 内存驻留空间 S 状态代码（D、R、S、T、Z） STIME 累计系统时间 SZ 物理页的大小（内存管理） TIME 累计 CPU 时间 TTY 控制终端的完整名称 UID 用户标识 WCHAN 等待通道 BSD 选项 显示哪些进程？ ps 与你的用户标识和终端相关的进程 ps a 与任何用户标识和终端相关的进程 ps e 所有进程（包含守护进程） ps p pid 与指定进程 ID pid 相关的进程 ps U userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TT STAT TIME COMMAND ps j USER PID PPID PGID SESS JOBC STAT TT TIME COMMAND ps l UID PID PPID CPU PRI NI VSZ RSS WCHAN STAT TT TIME COMMAND ps u USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND ps v PID STAT TIME SL RE PAGEN VSZ RSS LIM TSIZ %CPU %MEM COMMAND 有用的特殊组合 ps 显示自己的进程 ps ax 显示所有进程 ps aux 显示所有进程，完整输出 数据列说明： BSD 标题 含义 %CPU CPU 使用百分比 %MEM 真实内存使用百分比 CMD 正被执行的命令的名称 COMMAND 正被执行的命令的完整名称 CPU 短期 CPU 使用（调度） JOBC 作业控制统计 LIM 内存使用限额 NI nice 值，用户设置优先级 PAGEIN 总的缺页错误（内存错误 ） PGID 进程组号 PID 进程号ID PPID 父进程的进程ID PRI 调度有限级 RE 内存驻留时间（单位秒） RSS 内存驻留空间大小（内存管理） SESS 会话指针 SL 睡眠时间（单位秒） STARTED 定时启动 STAT 状态代码（O、R、S、T、Z） TIME 积累的CPU时间 TSIZ 文本大小（单位KB） TT 控制终端的缩写名称 TTY 控制终端的完整名称 UID 用户标识 USER 用户名 VSZ 虚拟大小（单位KB） WCHAN 等待通道 状态码说明： Linux、FreeBSD D 不可中断睡眠：等待时间结束（通常是I/O，D=“磁盘”） I 空闲：超过20秒的睡眠（仅仅适用于 FreeBSD） R 正在运行或可运行（可运行=正在运行队列中等待） S 可中断睡眠：等待事件结束 T 挂起：由作业控制信号挂起或者因为追踪而被挂起 Z 僵进程：终止后，父进程没有等待 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:3:0","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#ps-程序的使用"},{"categories":["技术"],"content":" ps 程序的使用ps 难用的原因是20世纪80年代，unix 分支：官方 Unix（AT\u0026T公司）、非官方（加利福尼亚大学伯克利分校）。UNIX 选项 和 BSD 选项。 unix 选项以连字符 - 开头，BSD 选项没有连字符。 # unix 选项 ps [-aefFly] [-p pid] [-u userid] # BSD ps [ajluvx] [p pid] [U userid] UNIX 选项 显示哪些进程？ ps 与您用户标识和终端相关的进程 ps -a 与任何用户标识和终端相关的进程 ps -e 所有进程（包含守护进程） ps -p pid 与指定进程 ID pid 相关的进程 ps -u userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TTY TIME CMD ps -f UID PID PPID C TTY TIME CMD ps -F UID PID PPID C SZ RSS STIME TTY TIME CMD ps -l F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD ps -ly S UID PID PPID C PRI NI RSS SZ WCHAN TTY TIME CMD 有用的特殊组合 ps 显示自己的进程 ps -ef 显示所有用户进程，完整给输出 ps -a 显示所有非守护进程的 进程 ps -t - （仅显示所有守护进程） 数据列说明： UNIX 标题 含义 ADDR 进程表中的 虚拟地址 C 处理器利用率（废弃率） CMD 正在执行的命令名 F 与进程相关的标识 NI nice 值，用于设置优先级 PID 进程 ID PPID 父进程 ID PRI 优先级（较大的数字：优先级低） RSS 内存驻留空间 S 状态代码（D、R、S、T、Z） STIME 累计系统时间 SZ 物理页的大小（内存管理） TIME 累计 CPU 时间 TTY 控制终端的完整名称 UID 用户标识 WCHAN 等待通道 BSD 选项 显示哪些进程？ ps 与你的用户标识和终端相关的进程 ps a 与任何用户标识和终端相关的进程 ps e 所有进程（包含守护进程） ps p pid 与指定进程 ID pid 相关的进程 ps U userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TT STAT TIME COMMAND ps j USER PID PPID PGID SESS JOBC STAT TT TIME COMMAND ps l UID PID PPID CPU PRI NI VSZ RSS WCHAN STAT TT TIME COMMAND ps u USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND ps v PID STAT TIME SL RE PAGEN VSZ RSS LIM TSIZ %CPU %MEM COMMAND 有用的特殊组合 ps 显示自己的进程 ps ax 显示所有进程 ps aux 显示所有进程，完整输出 数据列说明： BSD 标题 含义 %CPU CPU 使用百分比 %MEM 真实内存使用百分比 CMD 正被执行的命令的名称 COMMAND 正被执行的命令的完整名称 CPU 短期 CPU 使用（调度） JOBC 作业控制统计 LIM 内存使用限额 NI nice 值，用户设置优先级 PAGEIN 总的缺页错误（内存错误 ） PGID 进程组号 PID 进程号ID PPID 父进程的进程ID PRI 调度有限级 RE 内存驻留时间（单位秒） RSS 内存驻留空间大小（内存管理） SESS 会话指针 SL 睡眠时间（单位秒） STARTED 定时启动 STAT 状态代码（O、R、S、T、Z） TIME 积累的CPU时间 TSIZ 文本大小（单位KB） TT 控制终端的缩写名称 TTY 控制终端的完整名称 UID 用户标识 USER 用户名 VSZ 虚拟大小（单位KB） WCHAN 等待通道 状态码说明： Linux、FreeBSD D 不可中断睡眠：等待时间结束（通常是I/O，D=“磁盘”） I 空闲：超过20秒的睡眠（仅仅适用于 FreeBSD） R 正在运行或可运行（可运行=正在运行队列中等待） S 可中断睡眠：等待事件结束 T 挂起：由作业控制信号挂起或者因为追踪而被挂起 Z 僵进程：终止后，父进程没有等待 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:3:0","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#unix-选项"},{"categories":["技术"],"content":" ps 程序的使用ps 难用的原因是20世纪80年代，unix 分支：官方 Unix（AT\u0026T公司）、非官方（加利福尼亚大学伯克利分校）。UNIX 选项 和 BSD 选项。 unix 选项以连字符 - 开头，BSD 选项没有连字符。 # unix 选项 ps [-aefFly] [-p pid] [-u userid] # BSD ps [ajluvx] [p pid] [U userid] UNIX 选项 显示哪些进程？ ps 与您用户标识和终端相关的进程 ps -a 与任何用户标识和终端相关的进程 ps -e 所有进程（包含守护进程） ps -p pid 与指定进程 ID pid 相关的进程 ps -u userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TTY TIME CMD ps -f UID PID PPID C TTY TIME CMD ps -F UID PID PPID C SZ RSS STIME TTY TIME CMD ps -l F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD ps -ly S UID PID PPID C PRI NI RSS SZ WCHAN TTY TIME CMD 有用的特殊组合 ps 显示自己的进程 ps -ef 显示所有用户进程，完整给输出 ps -a 显示所有非守护进程的 进程 ps -t - （仅显示所有守护进程） 数据列说明： UNIX 标题 含义 ADDR 进程表中的 虚拟地址 C 处理器利用率（废弃率） CMD 正在执行的命令名 F 与进程相关的标识 NI nice 值，用于设置优先级 PID 进程 ID PPID 父进程 ID PRI 优先级（较大的数字：优先级低） RSS 内存驻留空间 S 状态代码（D、R、S、T、Z） STIME 累计系统时间 SZ 物理页的大小（内存管理） TIME 累计 CPU 时间 TTY 控制终端的完整名称 UID 用户标识 WCHAN 等待通道 BSD 选项 显示哪些进程？ ps 与你的用户标识和终端相关的进程 ps a 与任何用户标识和终端相关的进程 ps e 所有进程（包含守护进程） ps p pid 与指定进程 ID pid 相关的进程 ps U userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TT STAT TIME COMMAND ps j USER PID PPID PGID SESS JOBC STAT TT TIME COMMAND ps l UID PID PPID CPU PRI NI VSZ RSS WCHAN STAT TT TIME COMMAND ps u USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND ps v PID STAT TIME SL RE PAGEN VSZ RSS LIM TSIZ %CPU %MEM COMMAND 有用的特殊组合 ps 显示自己的进程 ps ax 显示所有进程 ps aux 显示所有进程，完整输出 数据列说明： BSD 标题 含义 %CPU CPU 使用百分比 %MEM 真实内存使用百分比 CMD 正被执行的命令的名称 COMMAND 正被执行的命令的完整名称 CPU 短期 CPU 使用（调度） JOBC 作业控制统计 LIM 内存使用限额 NI nice 值，用户设置优先级 PAGEIN 总的缺页错误（内存错误 ） PGID 进程组号 PID 进程号ID PPID 父进程的进程ID PRI 调度有限级 RE 内存驻留时间（单位秒） RSS 内存驻留空间大小（内存管理） SESS 会话指针 SL 睡眠时间（单位秒） STARTED 定时启动 STAT 状态代码（O、R、S、T、Z） TIME 积累的CPU时间 TSIZ 文本大小（单位KB） TT 控制终端的缩写名称 TTY 控制终端的完整名称 UID 用户标识 USER 用户名 VSZ 虚拟大小（单位KB） WCHAN 等待通道 状态码说明： Linux、FreeBSD D 不可中断睡眠：等待时间结束（通常是I/O，D=“磁盘”） I 空闲：超过20秒的睡眠（仅仅适用于 FreeBSD） R 正在运行或可运行（可运行=正在运行队列中等待） S 可中断睡眠：等待事件结束 T 挂起：由作业控制信号挂起或者因为追踪而被挂起 Z 僵进程：终止后，父进程没有等待 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:3:0","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#bsd-选项"},{"categories":["技术"],"content":" ps 程序的使用ps 难用的原因是20世纪80年代，unix 分支：官方 Unix（AT\u0026T公司）、非官方（加利福尼亚大学伯克利分校）。UNIX 选项 和 BSD 选项。 unix 选项以连字符 - 开头，BSD 选项没有连字符。 # unix 选项 ps [-aefFly] [-p pid] [-u userid] # BSD ps [ajluvx] [p pid] [U userid] UNIX 选项 显示哪些进程？ ps 与您用户标识和终端相关的进程 ps -a 与任何用户标识和终端相关的进程 ps -e 所有进程（包含守护进程） ps -p pid 与指定进程 ID pid 相关的进程 ps -u userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TTY TIME CMD ps -f UID PID PPID C TTY TIME CMD ps -F UID PID PPID C SZ RSS STIME TTY TIME CMD ps -l F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD ps -ly S UID PID PPID C PRI NI RSS SZ WCHAN TTY TIME CMD 有用的特殊组合 ps 显示自己的进程 ps -ef 显示所有用户进程，完整给输出 ps -a 显示所有非守护进程的 进程 ps -t - （仅显示所有守护进程） 数据列说明： UNIX 标题 含义 ADDR 进程表中的 虚拟地址 C 处理器利用率（废弃率） CMD 正在执行的命令名 F 与进程相关的标识 NI nice 值，用于设置优先级 PID 进程 ID PPID 父进程 ID PRI 优先级（较大的数字：优先级低） RSS 内存驻留空间 S 状态代码（D、R、S、T、Z） STIME 累计系统时间 SZ 物理页的大小（内存管理） TIME 累计 CPU 时间 TTY 控制终端的完整名称 UID 用户标识 WCHAN 等待通道 BSD 选项 显示哪些进程？ ps 与你的用户标识和终端相关的进程 ps a 与任何用户标识和终端相关的进程 ps e 所有进程（包含守护进程） ps p pid 与指定进程 ID pid 相关的进程 ps U userid 与指定用户标识 userid 相关的进程 显示哪些数据列？ ps PID TT STAT TIME COMMAND ps j USER PID PPID PGID SESS JOBC STAT TT TIME COMMAND ps l UID PID PPID CPU PRI NI VSZ RSS WCHAN STAT TT TIME COMMAND ps u USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND ps v PID STAT TIME SL RE PAGEN VSZ RSS LIM TSIZ %CPU %MEM COMMAND 有用的特殊组合 ps 显示自己的进程 ps ax 显示所有进程 ps aux 显示所有进程，完整输出 数据列说明： BSD 标题 含义 %CPU CPU 使用百分比 %MEM 真实内存使用百分比 CMD 正被执行的命令的名称 COMMAND 正被执行的命令的完整名称 CPU 短期 CPU 使用（调度） JOBC 作业控制统计 LIM 内存使用限额 NI nice 值，用户设置优先级 PAGEIN 总的缺页错误（内存错误 ） PGID 进程组号 PID 进程号ID PPID 父进程的进程ID PRI 调度有限级 RE 内存驻留时间（单位秒） RSS 内存驻留空间大小（内存管理） SESS 会话指针 SL 睡眠时间（单位秒） STARTED 定时启动 STAT 状态代码（O、R、S、T、Z） TIME 积累的CPU时间 TSIZ 文本大小（单位KB） TT 控制终端的缩写名称 TTY 控制终端的完整名称 UID 用户标识 USER 用户名 VSZ 虚拟大小（单位KB） WCHAN 等待通道 状态码说明： Linux、FreeBSD D 不可中断睡眠：等待时间结束（通常是I/O，D=“磁盘”） I 空闲：超过20秒的睡眠（仅仅适用于 FreeBSD） R 正在运行或可运行（可运行=正在运行队列中等待） S 可中断睡眠：等待事件结束 T 挂起：由作业控制信号挂起或者因为追踪而被挂起 Z 僵进程：终止后，父进程没有等待 ","date":"2022-05-07","objectID":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/:3:0","series":null,"tags":["折腾","进程","unix","linux"],"title":"进程和作业控制","uri":"/posts/unixs/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#状态码说明"},{"categories":["技术"],"content":" 排序、区域设置unix 的默认排序方式取决于你使用的区域设置，如：现在有A、a、B、b、C、c 几个文件，执行 ls 列举文件： 如果使用 C 区域设置，你会得到：A B C a b c (基于 ASCII 码)； 如果使用 en_US, 你将会得到： a A b B c C export LC_COLLATE=C ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:1:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#排序区域设置"},{"categories":["技术"],"content":" 目录栈相关pushd 、popd、dirs 三个命令将维护一个目录栈，我们可以通过调整栈的顺序实现快速的切换工作目录。 命令 动作 dirs 显示名称：home 显示为 ~ dirs -l 显示完整名称 dirs -v 显示名称：每行一个，并且有数字标识 pushd directory 改变工作目录：将 directory 压入到栈中 pushd +n 改变工作目录：将 #n 移动到栈顶 popd 改变工作目录：弹出栈顶 popd +n 从栈中移除目录 #n dirs -c 除当前工作目录外，移除栈中的全部目录 # 定义别名快速操作 alias d='dirs -v' alias p=pushd ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:2:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#目录栈相关"},{"categories":["技术"],"content":" 检查文件类型和颜色alias ls='ls -F --color=auto' alias la='ls -a' alias ldot='ls -d .??*' ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:3:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#检查文件类型和颜色"},{"categories":["技术"],"content":" 防止误删文件# 先 ls 检查删除的文件，再通过fc命令替换为rm alias del='fc -s ls=rm' ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:4:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#防止误删文件"},{"categories":["技术"],"content":" 利用历史记录alias a=alias alias info='date; who' alias h=\"fc -l\" alias r=\"fc -s\" # 使用 # h 显示记录 # r #number # r #name old=new ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:5:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#利用历史记录"},{"categories":["技术"],"content":" 掌握磁盘空间情况# -s(size，大小 单位 KB) ls -s # -h(human-readable, 适合人类阅读) ls -sh # -a(all,全部) # -c(count,统计) 末位显示总量 # -s(sum, 总和) # du(disk usage,磁盘使用) du [-achs] [name...] # df(disk free-space, 磁盘可用空间) df [-h] ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:6:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#掌握磁盘空间情况"},{"categories":["技术"],"content":" 块和分配单元：dumpe2fs文件系统中，空间以固定大小的组块进行分配，即 块（block），为文件所分配的最小磁盘空间数量。所以在一个块大小为1KB（1024字节）的文件系统中，仅仅包含1字节的文件也要占用一个完整的块，1025字节的数据文件需要两个块。 出于效率的考虑，当文件写入磁盘或其他存储介质上的时候，磁盘存储空间也是以固定大小的组块分配，即 分配单元（allocationuniut）或 簇（cluster）。分配单元的大小取决于文件系统和存储设备。 例如，我的 linux 系统上，块大小为 1 KB，但是磁盘分配单元 8KB。因此，一个只有一个字节的文件实际上要占用 8KB 的磁盘空间。 查看自己系统块大小和分配单元： # 创建一个很小的文件 echo a \u003e temp # 查看文件包含的数据的数量 文件大小在日期前面, 单位字节 2 个字节 ls -l temp # 查看文件占用的存储空间 4K 所以分配单元是 4K du -h temp # 查看块大小 单位：字节 sudo dumpe2fs /dev/vda1 | grep \"Block size\" ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:6:1","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#块和分配单元dumpe2fs"},{"categories":["技术"],"content":" 通配符 符号 含义 * 任何0个或多个字符 ？ 任何单个字符 [list] list 中的任何字符 [^list] 不在 list 中的任何字符 {string1|string2} 其中一个指定字符串 ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:7:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#通配符"},{"categories":["技术"],"content":" 预定义的字符 类 含义 类似于 [[:lower:]] 小写字母 [a-z] [[:upper:]] 大写字母 [A-Z] [[:digit:]] 数字 [0-9] [[:alnum:]] 大写小写字母与数字 [A-Za-z0-9] [[:alpha:]] 大写和小写字母 [A-Za-z] ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:7:1","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#预定义的字符"},{"categories":["技术"],"content":" Unix 为新文件指定权限的方式：umaskUnix 创建文件时，将根据文件类型为文件指定以下几种模式： 666: 不可执行的普通文件 777：可执行的普通文件 777： 目录 在这以初始模式上，Unix再减去用户掩码（user mask）。设置掩码的命令为：umask [mode] # 限制其他人写的权限 umask 022 # 显示当前的掩码 umask ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:8:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#unix-为新文件指定权限的方式umask"},{"categories":["技术"],"content":" 清空文件内容当删除文件时，文件所使用的实际磁盘空间还没被清除。文件系统只是将这部分磁盘空间标识为可重用。最终旧数据会被新数据覆盖。但是时间不确定，且有一些特殊的恢复工具可以恢复数据。 shred 程序的目的就是多次覆盖硬盘上已有的数据。 # -f(force,强制) # -u 覆盖完删除文件 # -v(verbose, 详细) # -z 填充零，默认是随机数据 shred -fuvz datafile ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:8:1","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#清空文件内容"},{"categories":["技术"],"content":" 链接的概念","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:9:0","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#链接的概念"},{"categories":["技术"],"content":" stat、ls -i i 节点（i-node）当 unix 创建文件时，unix 做了两件事。 Unix 在存储设备上保留一块空间用来存储数据。 Unix 创建一个**索引节点（index node）**或 **i 节点（i-node）**的结构。用来存放文件的基本信息。 查看文件的 i 节点内容： stat filename 文件系统将所有的 i 节点存放在一个大表中，称为 i 节点表（inode table），每个 i 节点由所谓的索引号或 i 节点号表示。 查看文件的节点号：ls -i filename 处理目录时候，就好像目录包含文件一样，其实，目录并不包含文件，目录只包含文件的名称及文件的 i 节点号。因此目录的内容相当小：只有一列名称，每个名称对应一个 i 节点号。 文件名和 i 节点之间的连接称为 链接。 ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:9:1","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#statls--i-i-节点i-node"},{"categories":["技术"],"content":" 多重链接Unix 文件系统允许多重链接。一个文件可以有不止一个名称。文件的唯一标识是 i 节点号，不是名称，所有多个名称可以引用到同一个 i 节点号。 链接的基本思想是同一个文件可能拥有不同的含义（取决于文件使用的环境）。并且 Unix 平等的对待所有的链接。 ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:9:2","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#多重链接"},{"categories":["技术"],"content":" 创建新链接: ln# file 是已有的普通文件的名称，newname是希望赋予链接的名称 ln file newname # 为一个或多个普通文件创建链接，并放到指定的目录中 ln file... directory rm 和 rmdir 其实是移除链接，只移除了文件名和 i 节点号之间的连接，如果文件没有链接了，Unix 会删除该文件。 ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:9:3","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#创建新链接-ln"},{"categories":["技术"],"content":" 符号链接：ln -s以上链接有两个限制：1. 不能为目录创建链接，2. 不能为不同的文件系统创建链接。 如果要实现以上需求，需要使用 符号链接（symbol link 或 symlink） 。 符号链接包含的不是文件的 i 节点号，而是文件的路径名。当访问符号链接时候，Unix 借助路径名查找文件。类似于 Windows 的快捷方式。 ls -l /bin/sh # 输出 /bin/sh 是一个指向 /bin/bash文件的符号链接 lrwxrwxrwx 1 root root 4 Aug 7 2020 /bin/sh -\u003e bash 为了区分两种链接： 常规的链接 : 硬链接（hard link） ls -l 可以查看硬链接数量，rm 可以移除硬链接 符号链接 : 软链接（soft link） 如果一个文件存在符号链接，删除文件，符号链接不会被删除，使用时则会报错。 当一个目录使用符号链接时，cd 和 pwd 既可以将符号链接视为一个实体，也可以将链接作为真实目录的一个跳板。 -L （logical， 逻辑）、-P（physical，物理）选项指定，默认 -L ","date":"2022-05-05","objectID":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/:9:4","series":null,"tags":["折腾","unix","linux"],"title":"Unix文件,别名等相关","uri":"/posts/unixs/unix%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D%E7%9B%B8%E5%85%B3/#符号链接ln--s"},{"categories":["诗歌"],"content":"Tiger got to hunt, bird got to fly; Man got to sit and wonder ‘why, why, why?’ Tiger got to sleep, bird got to land; Man got to tell himself he understand. — Kurt Vonnegut 翻译： 虎猎鸟飞人疑惑：为啥为啥为啥捏？ 虎息鸟憩人自语：好呗算我懂了呗。 ","date":"2021-12-24","objectID":"/posts/mess/tiger-got-to-hunt/:0:0","series":null,"tags":["诗歌"],"title":"Tiger Got to Hunt","uri":"/posts/mess/tiger-got-to-hunt/#"},{"categories":["技术"],"content":" 目标wsl 可以使用 win10 的代理。 ","date":"2021-12-11","objectID":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/:1:0","series":null,"tags":["代理","折腾","wsl"],"title":"Wsl设置代理","uri":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/#目标"},{"categories":["技术"],"content":" 环境说明win10 + 小飞机 + wsl2 ","date":"2021-12-11","objectID":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/:2:0","series":null,"tags":["代理","折腾","wsl"],"title":"Wsl设置代理","uri":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/#环境说明"},{"categories":["技术"],"content":" 步骤 WSL 中获取宿主机 IP WSL 每次启动的时候都会有不同的 IP 地址，所以并不能直接用静态的方式来设置代理。WSL2 会把 IP 写在 /etc/resolv.conf 中，因此可以用 cat /etc/resolv.conf | grep nameserver | awk '{ print $2 }' 这条指令获得宿主机 IP 。 WSL2 自己的 IP 可以用 hostname -I | awk '{print $1}' 得到。 设置代理 有了宿主机 IP 之后，就可以通过设置环境变量的方式设置代理了。这里端口需要自己填写，而且别忘了代理软件中设置允许来自局域网的连接。 export http_proxy='http://\u003cWindows IP\u003e:\u003cPort\u003e' export https_proxy='http://\u003cWindows IP\u003e:\u003cPort\u003e' 这种设置方式每次重启终端都得重新设置一遍，而且 IP 还得自己手打，还是挺麻烦的，这种时候就得靠脚本了！ 脚本实现 #!/bin/sh hostip=$(cat /etc/resolv.conf | grep nameserver | awk '{ print $2 }') wslip=$(hostname -I | awk '{print $1}') port=\u003cPORT\u003e PROXY_HTTP=\"http://${hostip}:${port}\" set_proxy(){ export http_proxy=\"${PROXY_HTTP}\" export HTTP_PROXY=\"${PROXY_HTTP}\" export https_proxy=\"${PROXY_HTTP}\" export HTTPS_proxy=\"${PROXY_HTTP}\" } unset_proxy(){ unset http_proxy unset HTTP_PROXY unset https_proxy unset HTTPS_PROXY } test_setting(){ echo \"Host ip:\" ${hostip} echo \"WSL ip:\" ${wslip} echo \"Current proxy:\" $https_proxy } if [ \"$1\" = \"set\" ] then set_proxy elif [ \"$1\" = \"unset\" ] then unset_proxy elif [ \"$1\" = \"test\" ] then test_setting else echo \"Unsupported arguments.\" fi 第 4 行 记得换成自己宿主机代理的端口！！！！！！ git 实现代理 如果希望 git 也能通过代理，可以分别在 set_proxy 和 unset_proxy 函数中加上如下命令 // 添加代理 git config --global http.proxy \"${PROXY_HTTP}\" git config --global https.proxy \"${PROXY_HTTP}\" // 移除代理 git config --global --unset http.proxy git config --global --unset https.proxy 分别加到上边脚本对应位置即可。 之后运行 . ./proxy.sh set 就可以自动设置代理了。unset 可以取消代理，test 可以查看代理状态，能够用来检查环境变量是否被正确修改。 运行的时候不要忘记之前的 .，或者使用 source ./proxy.sh set，只有这样才能够修改环境变量。 直接运行 ./proxy.sh set 或者 sh proxy.sh set，这样会是运行在一个子 shell 中，对当前 shell 没有效果。 自动执行 另外可以在 ~/.bashrc 中选择性的加上下面两句话，记得将里面的路径修改成你放这个脚本的路径。 alias proxy=\"source /path/to/proxy.sh\" . /path/to/proxy.sh set 第一句话可以为这个脚本设置别名 proxy，这样在任何路径下都可以通过 proxy 命令使用这个脚本了，之后在任何路径下，都可以随时都可以通过输入 proxy unset 来暂时取消代理。 第二句话就是在每次 shell 启动的时候运行该脚本实现自动设置代理，这样以后不用额外操作就默认设置好代理啦~ 防火墙设置 如果前面完成后已经可以正常使用了，那么下面就不用管了。如果你代理已经设置正确了，尤其是已经允许来自局域网的访问，但是依旧无法正常访问，代理的软件的确也没收到请求，那么很可能是被 Windows 的防火墙给拦截了。 可以先尝试 ping 宿主机 ip 和 telnet 代理的端口，检查是否连通。如果无法连通，则多半是防火墙的问题。 可以尝试在控制面板的防火墙面板左侧“允许应用或功能通过防火墙”，即上述界面中，打上勾允许代理软件通过防火墙。 或者可以尝试在高级设置中，入站规则中新建一个相关规则，如果你不是很了解，可以允许任何程序的任何协议，远程 IP 为 172.16.0.0/12 及 192.168.0.0/16 的入站请求。 使用 PowerShell 命令行创建一条给 WSL 网卡的防火墙策略： New-NetFirewallRule -DisplayName \"WSL\" -Direction Inbound -InterfaceAlias \"vEthernet (WSL)\" -Action Allow ","date":"2021-12-11","objectID":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/:3:0","series":null,"tags":["代理","折腾","wsl"],"title":"Wsl设置代理","uri":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/#步骤"},{"categories":["技术"],"content":" 参考文章主要部分 防火墙部分 防火墙手动设置 ","date":"2021-12-11","objectID":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/:4:0","series":null,"tags":["代理","折腾","wsl"],"title":"Wsl设置代理","uri":"/posts/wsl%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/#参考文章"},{"categories":["生活","技术"],"content":" 实验归纳 模型推演 仿真模拟 数据密集型科学发现 拓展阅读 ","date":"2021-11-24","objectID":"/posts/mess/%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%9A%844%E7%A7%8D%E8%8C%83%E5%BC%8F/:0:0","series":null,"tags":["日常","人间清醒"],"title":"科学研究的4种范式","uri":"/posts/mess/%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%9A%844%E7%A7%8D%E8%8C%83%E5%BC%8F/#"},{"categories":["生活"],"content":" 多巴胺模式： 吃、逛、买、看 恐惧驱动模式： 没有办法放手做事，瞻前顾后。 创造力模式： 关注点不在内在的状态，也不是去寻找快乐，而是想到要做成某事，关注点集中于当下正在做的事情。透过做一件事，将自己的注意力，从内心的小毛病小纠结转移到事情本身。 ","date":"2021-11-19","objectID":"/posts/mess/%E4%BA%BA%E7%94%9F3%E5%A4%A7%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/:0:0","series":null,"tags":["日常","人间清醒","得意忘形"],"title":"人生3大行为模式","uri":"/posts/mess/%E4%BA%BA%E7%94%9F3%E5%A4%A7%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/#"},{"categories":["生活"],"content":" 以各种各样的方式表现与别人不一样，来营造一种优越感（营造优越感的诱惑） 面对陌生事物的本能的恐惧和排挤 由于自身匮乏感，本能性的嫉妒 ","date":"2021-11-19","objectID":"/posts/mess/%E4%BA%BA%E7%94%9F3%E5%A4%A7%E5%8E%9F%E7%BD%AA/:0:0","series":null,"tags":["日常","人间清醒","得意忘形"],"title":"人生3大原罪","uri":"/posts/mess/%E4%BA%BA%E7%94%9F3%E5%A4%A7%E5%8E%9F%E7%BD%AA/#"},{"categories":["技术"],"content":" 开启与关闭 nginx关闭 nginx nginx -s stop 重新加载 nginx -s relaod ","date":"2021-11-19","objectID":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/:0:1","series":null,"tags":["nginx"],"title":"nginx相关","uri":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/#开启与关闭-nginx"},{"categories":["技术"],"content":" 配置文件 全局配置 影响 nginx 服务器整体运行的配置指令 eg：worker_processes 1; // 越大 并发越大 event 块 nginx 服务器与用户的网络连接 eg: worker_connections 1024; // 支持的最大连接数 http 块 http 全局块 server 块 ","date":"2021-11-19","objectID":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/:0:2","series":null,"tags":["nginx"],"title":"nginx相关","uri":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/#配置文件"},{"categories":["技术"],"content":" 配置实例 反向代理 访问 http://yii2.test:80 实际访问的是 http://vdong.test:8080 server { listen 80; server_name yii2.test *.yii2.test; root \"D:/laragon/www/yii2/web/\"; location / { proxy_pass http://vdong.test:8080; # ... } } 根据目录 跳转 不同 服务器 location ~ /yii/ { proxy_pass http://yii2-base.test; } location ~ /laravel/ { proxy_pass http://laravel.test:8080; } 负载均衡 http{ .... upstream php_upstream { # ip_hash; # fair; server 127.0.0.1:9001 weight=1 max_fails=1 fail_timeout=1; server 127.0.0.1:9002 weight=1 max_fails=1 fail_timeout=1; } .... } server{ .... location / { proxy_pass http://php_upstream; try_files $uri $uri/ /index.php$is_args$args; autoindex on; } .... } 负载策略： 轮询（默认） 时间顺序 逐一分配，down 了 剔除 weight 权重 根据权重 分配 ip_hash 解决 session 共享问题 fair ( 第三方 ) 根据响应时间分配，越短越多。 动静分离 动态请求和静态请求分离 location 根据后缀名 实现转发 ， expires 缓存时间 3d 3 天 location /www/{ root /data/; index index.html index.htm; } location /image/ { root /data/; autoindex on; } 高可用集群 两台 nginx； keepalived；虚拟 ip keepalived 其实 对于两台 主备服务器的， 路由作用 yum install keepalived -y 配置在 etc/keepalived/keepalived.conf 。 修改配置 在 /usr/local/src 添加检测脚本 ","date":"2021-11-19","objectID":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/:0:3","series":null,"tags":["nginx"],"title":"nginx相关","uri":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/#配置实例"},{"categories":["技术"],"content":" nginx 原理一个 master 多个 worker master 管理 监控， worker 争抢 client 热部署 独立进程，一个出问题，不影响其他的 io 多路复用机制， 每个 worker 都是 独立的进程，每个进程只有一个线程，通过异步非阻塞的方式来处理请求。 worker 和 cpu 核心数量相等，cpu 性能充分发挥。 worker_connection 连接数 发送一个请求， 占用了 2 / 4 个连接数。静态 不经过 php-fpm 的 。 nginx 一个 master， 4 个 worker， 每个 worker 支持最大连接数 1024，目前最大并发数是多少？ 4*1024/(2/4) 静态访问 ： worker_connection * worker_processes / 2 动态访问： worker_connection * worker_processes / 4 ","date":"2021-11-19","objectID":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/:0:4","series":null,"tags":["nginx"],"title":"nginx相关","uri":"/posts/php-web/nginx%E7%9B%B8%E5%85%B3/#nginx-原理"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag \u003ctagname\u003e用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a \u003ctagname\u003e -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin \u003ctagname\u003e可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d \u003ctagname\u003e可以删除一个本地标签； 命令git push origin :refs/tags/\u003ctagname\u003e可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#常用命令"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#clone-特定分支"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#日志查看"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#添加远程库"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#第一次推送"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#比较差异"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#配置别名"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#标签"},{"categories":["技术"],"content":" 常用命令 clone 特定分支git clone -b v5.12 git@gitee.com:xxx/xxx.git 日志查看git log --graph --pretty=oneline --abbrev-commit 添加远程库git remote add origin git@github.com:michaelliao/learngit.git 第一次推送git push -u origin master 比较差异git diff readme.txt 配置别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" git config --global alias.lg \"log --graph --pretty=oneline --abbrev-commit\" git config --global alias.st \"status\" git config --global alias.ck \"checkout\" git config --global alias.br \"branch\" 标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin 可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 获取今天的日志git log --since=\"6am\" ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#获取今天的日志"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#错误记录"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#pull-或-merge-时错误"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#git如何忽略已经提交的文件-gitignore文件无效"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#文件名大小写问题"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#换行符问题"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#修改最后一次commit的message"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#文件名中文-xxx-八进制中文乱码"},{"categories":["技术"],"content":" 错误记录 pull 或 merge 时错误fatal: refusing to merge unrelated histories 解决方案： 在你操作命令后面加–allow-unrelated-histories eg: git merge master –allow-unrelated-histories git pull origin master –allow-unrelated-histories git如何忽略已经提交的文件 (.gitignore文件无效)解决方案： git rm -r --cached 要忽略的文件 (如: git rm -r --cached build/*, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定git rm -r --cached .) git add . git commit -m \" commet for commit .....\" git push 文件名大小写问题默认对大小写不敏感 文件名相同 造成 Changes not staged for commit 错误 解决方案： git config --global core.ignorecase false 换行符问题win上会提示CRLF will be replaced by LF 解决方案： https://stackmirror.com/questions/5834014 git config --global core.autocrlf input 修改最后一次commit的messagegit commit --amend 文件名中文 \\xxx 八进制中文乱码git config core.quotepath false --global 删除远程分支, 后还显示git push origin -d git remote prune origin ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#删除远程分支-后还显示"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD \u003cfileName\u003e 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log \u003cfilename\u003e git checkout \u003ccommitID\u003e \u003cfileName\u003e 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#撤销"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log git checkout 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#场景1-本地修改了一些文件未-add-但是想放弃修改"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log git checkout 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#场景11-本地新增了一些文件未add想放弃新增"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log git checkout 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#场景2执行了-add--但是想放弃修改"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log git checkout 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#场景3commit-了想修改且不想产生新的提交"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log git checkout 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#场景4commit-了想撤销到某次-commit"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log git checkout 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#场景5-已经-push-了撤销制定文件到指定版本"},{"categories":["技术"],"content":" 撤销 场景1 ：本地修改了一些文件，未 add ，但是想放弃修改git checkout fileName // or git checkout . 场景1.1： 本地新增了一些文件，未add，想放弃新增# 删除文件 rm filename # 删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！ git clean -xdf # 同上，但是还会处理文件夹 git clean -xdff 场景2：执行了 add , 但是想放弃修改git reset HEAD 场景3：commit 了，想修改，且不想产生新的提交git add fileName git commit -amend -m '说明' 场景4：commit 了，想撤销到某次 commitgit reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景5： 已经 push 了，撤销制定文件到指定版本# 查看文件版本 git log git checkout 场景6： 撤销最后一次提交git revert HEAD // 是反做了目标版本，产生一个新的commits git reset --hard HEAD^ // 会删除目标版本后的版本 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#场景6-撤销最后一次提交"},{"categories":["技术"],"content":" 学习网站learngitbranching 图解git githowto git飞行规则 ","date":"2021-11-04","objectID":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:4","series":null,"tags":["git"],"title":"git 常用命令","uri":"/posts/php-web/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#学习网站"},{"categories":["技术"],"content":" 版本管理有一个仓库（可以自建，也可以用线上的），将开发者本地的代码每次修改管理起来，可以查看修改记录，回滚等，常用的管理工具有svn 、git等，主流 git。 简要流程： 修改代码 提交修改到仓库 当然反过来也可以： 从仓库下载代码到本地 svn： 叫检出（ svn checkout path）； git 叫 拉取（git pull） ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:1","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#版本管理"},{"categories":["技术"],"content":" 服务器同步本地修改的代码要上传服务器，才能生效 简要流程： 修改代码 上传服务器（ftp，sftp： 直接本地上传；或者版本仓库里 拉取） ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:2","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#服务器同步"},{"categories":["技术"],"content":" 自动部署可以发现第一步是一样的，我们可以把服务器当作一个新的本地环境，我们可以使用计算机，帮我们简化操作流程。 简化后的流程： 修改代码 提交修改到代码仓库 从仓库拉取代码到服务器，即完成了上传服务器 以git为例，我们看一些实际部署（手动）： 本地计算机执行： git commit -am 修改了一些文件 本地计算机执行： git push origin/master 提交远程版本仓库 服务器执行： git pull 服务器拉取版本仓库文件 webhook 帮助我们自动实现这个拉取过程。 ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:3","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#自动部署"},{"categories":["技术"],"content":" webhook自动部署的原理 webhooks：其实就是类似于触发事件 A事件发生 —-触发—-\u003e B事件 push事件 —-触发—-\u003e post : www.a.com/pull.php pull.php 完成工作： 切到网站根目录，git pull 拉取仓库代码 核心代码： shell_exec(“cd /home/www/www.a.com \u0026\u0026 git pull 2\u003e\u00261”); ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:4","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#webhook自动部署的原理"},{"categories":["技术"],"content":" 具体实现 生成并部署SSH key 服务器上生成ssh key ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... # 三次回车即可生成 ssh key 查看公钥并添加的码云 cat ~/.ssh/id_rsa.pub # ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 复制以上公钥，添加到仓库 “部署公钥管理”。 测试出现如下表示添加成功 ssh -T git@gitee.com Hi Anonymous! You've successfully authenticated, but GITEE.COM does not provide shell access. Note: Perhaps the current use is DeployKey. Note: DeployKey only supports pull/fetch operations 服务器初始化clone仓库$ cd /home/wwwroot/ # 代码存放目录 $ git clone git@gitee.com:vdong/t.whaoot.com.git 准备php代码\u003c?php // 本地仓库路径 $local = '/home/wwwroot/t.whaoot.com'; // 安全验证字符串，为空则不验证 $token = '111111'; // 如果启用验证，并且验证失败，返回错误 $httpToken = isset($_SERVER['HTTP_X_GITEE_TOKEN']) ? $_SERVER['HTTP_X_GITEE_TOKEN'] : ''; if ($token \u0026\u0026 $httpToken != $token) { header('HTTP/1.1 403 Permission Denied'); die('Permission denied.'); } // 如果仓库目录不存在，返回错误 if (!is_dir($local)) { header('HTTP/1.1 500 Internal Server Error'); die('Local directory is missing'); } //如果请求体内容为空，返回错误 $payload = file_get_contents('php://input'); if (!$payload) { header('HTTP/1.1 400 Bad Request'); die('HTTP HEADER or POST is missing.'); } /* * 这里有几点需要注意： * * 1.确保PHP正常执行系统命令。写一个PHP文件，内容： * `\u003c?php shell_exec('ls -la')` * 在通过浏览器访问这个文件，能够输出目录结构说明PHP可以运行系统命令。 * 否则 修改web服务器上php.ini的 disable_functions 列表，去掉 shell_exec; 重启php-fpm服务 * * 2、PHP一般使用www-data或者nginx用户运行，PHP通过脚本执行系统命令也是用这个用户， * 所以必须确保在该用户家目录（一般是/home/www-data或/home/nginx）下有.ssh目录和 * 一些授权文件，以及git配置文件，如下： * ``` * /root/.ssh * + .ssh * - authorized_keys * - config * - id_rsa * - id_rsa.pub * - known_hosts * - .gitconfig * ``` * * 3.在执行的命令后面加上2\u003e\u00261可以输出详细信息，确定错误位置 * * 4.git目录权限问题。比如： * `fatal: Unable to create '/data/www/html/awaimai/.git/index.lock': Permission denied` * 那就是PHP用户没有写权限，需要给目录授予权限: * `` * sudo chown -R www:www /data/www/html/awaimai` * sudo chmod -R g+w /data/www/html/awaimai * ``` * * 5.SSH认证问题。如果是通过SSH认证，有可能提示错误： * `Could not create directory '/.ssh'.` * 或者 * `Host key verification failed.` * .ssh 要放到对应的用户目录下 * 例如： php 是以 www 用户运行的， /home/www/.ssh * */ #以可写权限打开git_new.log文件，用于记录git日志 $fs = fopen('/home/www/git.t.whaoot.com.log', 'a'); fwrite($fs, '================ Update Start ==============='.PHP_EOL.PHP_EOL); #获取请求端的IP $client_ip = $_SERVER['REMOTE_ADDR']; #将时间与请求端IP写入日志文件 fwrite($fs, 'Request on ['.date(\"Y-m-d H:i:s\").'] from ['.$client_ip.']'.PHP_EOL); #执行shell命令cd到网站根目录执行git pull操作并把返回信息赋值给变量output $output=shell_exec(\"cd {$local} \u0026\u0026 git pull 2\u003e\u00261\"); #将日志信息写入日志文件中 fwrite($fs, 'Info:'. $output.PHP_EOL); fwrite($fs,PHP_EOL. '================ Update End ==============='.PHP_EOL.PHP_EOL); #关闭日志文件 echo $output die(\"done \" . date('Y-m-d H:i:s', time())); $fs and fclose($fs); 绑定webhooks去码云设置 WebHooks，点击测试 参考链接：https://www.awaimai.com/2203.html https://blog.csdn.net/gbenson/article/details/84346696 ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:5","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#具体实现"},{"categories":["技术"],"content":" 具体实现 生成并部署SSH key 服务器上生成ssh key ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... # 三次回车即可生成 ssh key 查看公钥并添加的码云 cat ~/.ssh/id_rsa.pub # ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 复制以上公钥，添加到仓库 “部署公钥管理”。 测试出现如下表示添加成功 ssh -T git@gitee.com Hi Anonymous! You've successfully authenticated, but GITEE.COM does not provide shell access. Note: Perhaps the current use is DeployKey. Note: DeployKey only supports pull/fetch operations 服务器初始化clone仓库$ cd /home/wwwroot/ # 代码存放目录 $ git clone git@gitee.com:vdong/t.whaoot.com.git 准备php代码\u003c?php // 本地仓库路径 $local = '/home/wwwroot/t.whaoot.com'; // 安全验证字符串，为空则不验证 $token = '111111'; // 如果启用验证，并且验证失败，返回错误 $httpToken = isset($_SERVER['HTTP_X_GITEE_TOKEN']) ? $_SERVER['HTTP_X_GITEE_TOKEN'] : ''; if ($token \u0026\u0026 $httpToken != $token) { header('HTTP/1.1 403 Permission Denied'); die('Permission denied.'); } // 如果仓库目录不存在，返回错误 if (!is_dir($local)) { header('HTTP/1.1 500 Internal Server Error'); die('Local directory is missing'); } //如果请求体内容为空，返回错误 $payload = file_get_contents('php://input'); if (!$payload) { header('HTTP/1.1 400 Bad Request'); die('HTTP HEADER or POST is missing.'); } /* * 这里有几点需要注意： * * 1.确保PHP正常执行系统命令。写一个PHP文件，内容： * `\u003c?php shell_exec('ls -la')` * 在通过浏览器访问这个文件，能够输出目录结构说明PHP可以运行系统命令。 * 否则 修改web服务器上php.ini的 disable_functions 列表，去掉 shell_exec; 重启php-fpm服务 * * 2、PHP一般使用www-data或者nginx用户运行，PHP通过脚本执行系统命令也是用这个用户， * 所以必须确保在该用户家目录（一般是/home/www-data或/home/nginx）下有.ssh目录和 * 一些授权文件，以及git配置文件，如下： * ``` * /root/.ssh * + .ssh * - authorized_keys * - config * - id_rsa * - id_rsa.pub * - known_hosts * - .gitconfig * ``` * * 3.在执行的命令后面加上2\u003e\u00261可以输出详细信息，确定错误位置 * * 4.git目录权限问题。比如： * `fatal: Unable to create '/data/www/html/awaimai/.git/index.lock': Permission denied` * 那就是PHP用户没有写权限，需要给目录授予权限: * `` * sudo chown -R www:www /data/www/html/awaimai` * sudo chmod -R g+w /data/www/html/awaimai * ``` * * 5.SSH认证问题。如果是通过SSH认证，有可能提示错误： * `Could not create directory '/.ssh'.` * 或者 * `Host key verification failed.` * .ssh 要放到对应的用户目录下 * 例如： php 是以 www 用户运行的， /home/www/.ssh * */ #以可写权限打开git_new.log文件，用于记录git日志 $fs = fopen('/home/www/git.t.whaoot.com.log', 'a'); fwrite($fs, '================ Update Start ==============='.PHP_EOL.PHP_EOL); #获取请求端的IP $client_ip = $_SERVER['REMOTE_ADDR']; #将时间与请求端IP写入日志文件 fwrite($fs, 'Request on ['.date(\"Y-m-d H:i:s\").'] from ['.$client_ip.']'.PHP_EOL); #执行shell命令cd到网站根目录执行git pull操作并把返回信息赋值给变量output $output=shell_exec(\"cd {$local} \u0026\u0026 git pull 2\u003e\u00261\"); #将日志信息写入日志文件中 fwrite($fs, 'Info:'. $output.PHP_EOL); fwrite($fs,PHP_EOL. '================ Update End ==============='.PHP_EOL.PHP_EOL); #关闭日志文件 echo $output die(\"done \" . date('Y-m-d H:i:s', time())); $fs and fclose($fs); 绑定webhooks去码云设置 WebHooks，点击测试 参考链接：https://www.awaimai.com/2203.html https://blog.csdn.net/gbenson/article/details/84346696 ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:5","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#生成并部署ssh-key"},{"categories":["技术"],"content":" 具体实现 生成并部署SSH key 服务器上生成ssh key ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... # 三次回车即可生成 ssh key 查看公钥并添加的码云 cat ~/.ssh/id_rsa.pub # ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 复制以上公钥，添加到仓库 “部署公钥管理”。 测试出现如下表示添加成功 ssh -T git@gitee.com Hi Anonymous! You've successfully authenticated, but GITEE.COM does not provide shell access. Note: Perhaps the current use is DeployKey. Note: DeployKey only supports pull/fetch operations 服务器初始化clone仓库$ cd /home/wwwroot/ # 代码存放目录 $ git clone git@gitee.com:vdong/t.whaoot.com.git 准备php代码\u003c?php // 本地仓库路径 $local = '/home/wwwroot/t.whaoot.com'; // 安全验证字符串，为空则不验证 $token = '111111'; // 如果启用验证，并且验证失败，返回错误 $httpToken = isset($_SERVER['HTTP_X_GITEE_TOKEN']) ? $_SERVER['HTTP_X_GITEE_TOKEN'] : ''; if ($token \u0026\u0026 $httpToken != $token) { header('HTTP/1.1 403 Permission Denied'); die('Permission denied.'); } // 如果仓库目录不存在，返回错误 if (!is_dir($local)) { header('HTTP/1.1 500 Internal Server Error'); die('Local directory is missing'); } //如果请求体内容为空，返回错误 $payload = file_get_contents('php://input'); if (!$payload) { header('HTTP/1.1 400 Bad Request'); die('HTTP HEADER or POST is missing.'); } /* * 这里有几点需要注意： * * 1.确保PHP正常执行系统命令。写一个PHP文件，内容： * `\u003c?php shell_exec('ls -la')` * 在通过浏览器访问这个文件，能够输出目录结构说明PHP可以运行系统命令。 * 否则 修改web服务器上php.ini的 disable_functions 列表，去掉 shell_exec; 重启php-fpm服务 * * 2、PHP一般使用www-data或者nginx用户运行，PHP通过脚本执行系统命令也是用这个用户， * 所以必须确保在该用户家目录（一般是/home/www-data或/home/nginx）下有.ssh目录和 * 一些授权文件，以及git配置文件，如下： * ``` * /root/.ssh * + .ssh * - authorized_keys * - config * - id_rsa * - id_rsa.pub * - known_hosts * - .gitconfig * ``` * * 3.在执行的命令后面加上2\u003e\u00261可以输出详细信息，确定错误位置 * * 4.git目录权限问题。比如： * `fatal: Unable to create '/data/www/html/awaimai/.git/index.lock': Permission denied` * 那就是PHP用户没有写权限，需要给目录授予权限: * `` * sudo chown -R www:www /data/www/html/awaimai` * sudo chmod -R g+w /data/www/html/awaimai * ``` * * 5.SSH认证问题。如果是通过SSH认证，有可能提示错误： * `Could not create directory '/.ssh'.` * 或者 * `Host key verification failed.` * .ssh 要放到对应的用户目录下 * 例如： php 是以 www 用户运行的， /home/www/.ssh * */ #以可写权限打开git_new.log文件，用于记录git日志 $fs = fopen('/home/www/git.t.whaoot.com.log', 'a'); fwrite($fs, '================ Update Start ==============='.PHP_EOL.PHP_EOL); #获取请求端的IP $client_ip = $_SERVER['REMOTE_ADDR']; #将时间与请求端IP写入日志文件 fwrite($fs, 'Request on ['.date(\"Y-m-d H:i:s\").'] from ['.$client_ip.']'.PHP_EOL); #执行shell命令cd到网站根目录执行git pull操作并把返回信息赋值给变量output $output=shell_exec(\"cd {$local} \u0026\u0026 git pull 2\u003e\u00261\"); #将日志信息写入日志文件中 fwrite($fs, 'Info:'. $output.PHP_EOL); fwrite($fs,PHP_EOL. '================ Update End ==============='.PHP_EOL.PHP_EOL); #关闭日志文件 echo $output die(\"done \" . date('Y-m-d H:i:s', time())); $fs and fclose($fs); 绑定webhooks去码云设置 WebHooks，点击测试 参考链接：https://www.awaimai.com/2203.html https://blog.csdn.net/gbenson/article/details/84346696 ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:5","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#服务器初始化clone仓库"},{"categories":["技术"],"content":" 具体实现 生成并部署SSH key 服务器上生成ssh key ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... # 三次回车即可生成 ssh key 查看公钥并添加的码云 cat ~/.ssh/id_rsa.pub # ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 复制以上公钥，添加到仓库 “部署公钥管理”。 测试出现如下表示添加成功 ssh -T git@gitee.com Hi Anonymous! You've successfully authenticated, but GITEE.COM does not provide shell access. Note: Perhaps the current use is DeployKey. Note: DeployKey only supports pull/fetch operations 服务器初始化clone仓库$ cd /home/wwwroot/ # 代码存放目录 $ git clone git@gitee.com:vdong/t.whaoot.com.git 准备php代码\u003c?php // 本地仓库路径 $local = '/home/wwwroot/t.whaoot.com'; // 安全验证字符串，为空则不验证 $token = '111111'; // 如果启用验证，并且验证失败，返回错误 $httpToken = isset($_SERVER['HTTP_X_GITEE_TOKEN']) ? $_SERVER['HTTP_X_GITEE_TOKEN'] : ''; if ($token \u0026\u0026 $httpToken != $token) { header('HTTP/1.1 403 Permission Denied'); die('Permission denied.'); } // 如果仓库目录不存在，返回错误 if (!is_dir($local)) { header('HTTP/1.1 500 Internal Server Error'); die('Local directory is missing'); } //如果请求体内容为空，返回错误 $payload = file_get_contents('php://input'); if (!$payload) { header('HTTP/1.1 400 Bad Request'); die('HTTP HEADER or POST is missing.'); } /* * 这里有几点需要注意： * * 1.确保PHP正常执行系统命令。写一个PHP文件，内容： * `\u003c?php shell_exec('ls -la')` * 在通过浏览器访问这个文件，能够输出目录结构说明PHP可以运行系统命令。 * 否则 修改web服务器上php.ini的 disable_functions 列表，去掉 shell_exec; 重启php-fpm服务 * * 2、PHP一般使用www-data或者nginx用户运行，PHP通过脚本执行系统命令也是用这个用户， * 所以必须确保在该用户家目录（一般是/home/www-data或/home/nginx）下有.ssh目录和 * 一些授权文件，以及git配置文件，如下： * ``` * /root/.ssh * + .ssh * - authorized_keys * - config * - id_rsa * - id_rsa.pub * - known_hosts * - .gitconfig * ``` * * 3.在执行的命令后面加上2\u003e\u00261可以输出详细信息，确定错误位置 * * 4.git目录权限问题。比如： * `fatal: Unable to create '/data/www/html/awaimai/.git/index.lock': Permission denied` * 那就是PHP用户没有写权限，需要给目录授予权限: * `` * sudo chown -R www:www /data/www/html/awaimai` * sudo chmod -R g+w /data/www/html/awaimai * ``` * * 5.SSH认证问题。如果是通过SSH认证，有可能提示错误： * `Could not create directory '/.ssh'.` * 或者 * `Host key verification failed.` * .ssh 要放到对应的用户目录下 * 例如： php 是以 www 用户运行的， /home/www/.ssh * */ #以可写权限打开git_new.log文件，用于记录git日志 $fs = fopen('/home/www/git.t.whaoot.com.log', 'a'); fwrite($fs, '================ Update Start ==============='.PHP_EOL.PHP_EOL); #获取请求端的IP $client_ip = $_SERVER['REMOTE_ADDR']; #将时间与请求端IP写入日志文件 fwrite($fs, 'Request on ['.date(\"Y-m-d H:i:s\").'] from ['.$client_ip.']'.PHP_EOL); #执行shell命令cd到网站根目录执行git pull操作并把返回信息赋值给变量output $output=shell_exec(\"cd {$local} \u0026\u0026 git pull 2\u003e\u00261\"); #将日志信息写入日志文件中 fwrite($fs, 'Info:'. $output.PHP_EOL); fwrite($fs,PHP_EOL. '================ Update End ==============='.PHP_EOL.PHP_EOL); #关闭日志文件 echo $output die(\"done \" . date('Y-m-d H:i:s', time())); $fs and fclose($fs); 绑定webhooks去码云设置 WebHooks，点击测试 参考链接：https://www.awaimai.com/2203.html https://blog.csdn.net/gbenson/article/details/84346696 ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:5","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#准备php代码"},{"categories":["技术"],"content":" 具体实现 生成并部署SSH key 服务器上生成ssh key ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... # 三次回车即可生成 ssh key 查看公钥并添加的码云 cat ~/.ssh/id_rsa.pub # ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 复制以上公钥，添加到仓库 “部署公钥管理”。 测试出现如下表示添加成功 ssh -T git@gitee.com Hi Anonymous! You've successfully authenticated, but GITEE.COM does not provide shell access. Note: Perhaps the current use is DeployKey. Note: DeployKey only supports pull/fetch operations 服务器初始化clone仓库$ cd /home/wwwroot/ # 代码存放目录 $ git clone git@gitee.com:vdong/t.whaoot.com.git 准备php代码\u003c?php // 本地仓库路径 $local = '/home/wwwroot/t.whaoot.com'; // 安全验证字符串，为空则不验证 $token = '111111'; // 如果启用验证，并且验证失败，返回错误 $httpToken = isset($_SERVER['HTTP_X_GITEE_TOKEN']) ? $_SERVER['HTTP_X_GITEE_TOKEN'] : ''; if ($token \u0026\u0026 $httpToken != $token) { header('HTTP/1.1 403 Permission Denied'); die('Permission denied.'); } // 如果仓库目录不存在，返回错误 if (!is_dir($local)) { header('HTTP/1.1 500 Internal Server Error'); die('Local directory is missing'); } //如果请求体内容为空，返回错误 $payload = file_get_contents('php://input'); if (!$payload) { header('HTTP/1.1 400 Bad Request'); die('HTTP HEADER or POST is missing.'); } /* * 这里有几点需要注意： * * 1.确保PHP正常执行系统命令。写一个PHP文件，内容： * `\u003c?php shell_exec('ls -la')` * 在通过浏览器访问这个文件，能够输出目录结构说明PHP可以运行系统命令。 * 否则 修改web服务器上php.ini的 disable_functions 列表，去掉 shell_exec; 重启php-fpm服务 * * 2、PHP一般使用www-data或者nginx用户运行，PHP通过脚本执行系统命令也是用这个用户， * 所以必须确保在该用户家目录（一般是/home/www-data或/home/nginx）下有.ssh目录和 * 一些授权文件，以及git配置文件，如下： * ``` * /root/.ssh * + .ssh * - authorized_keys * - config * - id_rsa * - id_rsa.pub * - known_hosts * - .gitconfig * ``` * * 3.在执行的命令后面加上2\u003e\u00261可以输出详细信息，确定错误位置 * * 4.git目录权限问题。比如： * `fatal: Unable to create '/data/www/html/awaimai/.git/index.lock': Permission denied` * 那就是PHP用户没有写权限，需要给目录授予权限: * `` * sudo chown -R www:www /data/www/html/awaimai` * sudo chmod -R g+w /data/www/html/awaimai * ``` * * 5.SSH认证问题。如果是通过SSH认证，有可能提示错误： * `Could not create directory '/.ssh'.` * 或者 * `Host key verification failed.` * .ssh 要放到对应的用户目录下 * 例如： php 是以 www 用户运行的， /home/www/.ssh * */ #以可写权限打开git_new.log文件，用于记录git日志 $fs = fopen('/home/www/git.t.whaoot.com.log', 'a'); fwrite($fs, '================ Update Start ==============='.PHP_EOL.PHP_EOL); #获取请求端的IP $client_ip = $_SERVER['REMOTE_ADDR']; #将时间与请求端IP写入日志文件 fwrite($fs, 'Request on ['.date(\"Y-m-d H:i:s\").'] from ['.$client_ip.']'.PHP_EOL); #执行shell命令cd到网站根目录执行git pull操作并把返回信息赋值给变量output $output=shell_exec(\"cd {$local} \u0026\u0026 git pull 2\u003e\u00261\"); #将日志信息写入日志文件中 fwrite($fs, 'Info:'. $output.PHP_EOL); fwrite($fs,PHP_EOL. '================ Update End ==============='.PHP_EOL.PHP_EOL); #关闭日志文件 echo $output die(\"done \" . date('Y-m-d H:i:s', time())); $fs and fclose($fs); 绑定webhooks去码云设置 WebHooks，点击测试 参考链接：https://www.awaimai.com/2203.html https://blog.csdn.net/gbenson/article/details/84346696 ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:5","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#绑定webhooks"},{"categories":["技术"],"content":" 具体实现 生成并部署SSH key 服务器上生成ssh key ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... # 三次回车即可生成 ssh key 查看公钥并添加的码云 cat ~/.ssh/id_rsa.pub # ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 复制以上公钥，添加到仓库 “部署公钥管理”。 测试出现如下表示添加成功 ssh -T git@gitee.com Hi Anonymous! You've successfully authenticated, but GITEE.COM does not provide shell access. Note: Perhaps the current use is DeployKey. Note: DeployKey only supports pull/fetch operations 服务器初始化clone仓库$ cd /home/wwwroot/ # 代码存放目录 $ git clone git@gitee.com:vdong/t.whaoot.com.git 准备php代码\u003c?php // 本地仓库路径 $local = '/home/wwwroot/t.whaoot.com'; // 安全验证字符串，为空则不验证 $token = '111111'; // 如果启用验证，并且验证失败，返回错误 $httpToken = isset($_SERVER['HTTP_X_GITEE_TOKEN']) ? $_SERVER['HTTP_X_GITEE_TOKEN'] : ''; if ($token \u0026\u0026 $httpToken != $token) { header('HTTP/1.1 403 Permission Denied'); die('Permission denied.'); } // 如果仓库目录不存在，返回错误 if (!is_dir($local)) { header('HTTP/1.1 500 Internal Server Error'); die('Local directory is missing'); } //如果请求体内容为空，返回错误 $payload = file_get_contents('php://input'); if (!$payload) { header('HTTP/1.1 400 Bad Request'); die('HTTP HEADER or POST is missing.'); } /* * 这里有几点需要注意： * * 1.确保PHP正常执行系统命令。写一个PHP文件，内容： * `\u003c?php shell_exec('ls -la')` * 在通过浏览器访问这个文件，能够输出目录结构说明PHP可以运行系统命令。 * 否则 修改web服务器上php.ini的 disable_functions 列表，去掉 shell_exec; 重启php-fpm服务 * * 2、PHP一般使用www-data或者nginx用户运行，PHP通过脚本执行系统命令也是用这个用户， * 所以必须确保在该用户家目录（一般是/home/www-data或/home/nginx）下有.ssh目录和 * 一些授权文件，以及git配置文件，如下： * ``` * /root/.ssh * + .ssh * - authorized_keys * - config * - id_rsa * - id_rsa.pub * - known_hosts * - .gitconfig * ``` * * 3.在执行的命令后面加上2\u003e\u00261可以输出详细信息，确定错误位置 * * 4.git目录权限问题。比如： * `fatal: Unable to create '/data/www/html/awaimai/.git/index.lock': Permission denied` * 那就是PHP用户没有写权限，需要给目录授予权限: * `` * sudo chown -R www:www /data/www/html/awaimai` * sudo chmod -R g+w /data/www/html/awaimai * ``` * * 5.SSH认证问题。如果是通过SSH认证，有可能提示错误： * `Could not create directory '/.ssh'.` * 或者 * `Host key verification failed.` * .ssh 要放到对应的用户目录下 * 例如： php 是以 www 用户运行的， /home/www/.ssh * */ #以可写权限打开git_new.log文件，用于记录git日志 $fs = fopen('/home/www/git.t.whaoot.com.log', 'a'); fwrite($fs, '================ Update Start ==============='.PHP_EOL.PHP_EOL); #获取请求端的IP $client_ip = $_SERVER['REMOTE_ADDR']; #将时间与请求端IP写入日志文件 fwrite($fs, 'Request on ['.date(\"Y-m-d H:i:s\").'] from ['.$client_ip.']'.PHP_EOL); #执行shell命令cd到网站根目录执行git pull操作并把返回信息赋值给变量output $output=shell_exec(\"cd {$local} \u0026\u0026 git pull 2\u003e\u00261\"); #将日志信息写入日志文件中 fwrite($fs, 'Info:'. $output.PHP_EOL); fwrite($fs,PHP_EOL. '================ Update End ==============='.PHP_EOL.PHP_EOL); #关闭日志文件 echo $output die(\"done \" . date('Y-m-d H:i:s', time())); $fs and fclose($fs); 绑定webhooks去码云设置 WebHooks，点击测试 参考链接：https://www.awaimai.com/2203.html https://blog.csdn.net/gbenson/article/details/84346696 ","date":"2021-11-04","objectID":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/:0:5","series":null,"tags":["php","webhook"],"title":"PHP webhook 部署码云","uri":"/posts/php-web/php-webhooks-%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/#参考链接"},{"categories":["技术"],"content":"composer require “mk-j/php_xlsxwriter” –no-update ","date":"2021-11-04","objectID":"/posts/php-web/composer/:0:0","series":null,"tags":["composer"],"title":"composer","uri":"/posts/php-web/composer/#"},{"categories":["技术"],"content":" 版本说明“require”: { “vendor/package”: “1.3.2”, // exactly 1.3.2 // \u003e, \u003c, \u003e=, \u003c= | specify upper / lower bounds \"vendor/package\": \"\u003e=1.3.2\", // anything above or equal to 1.3.2 \"vendor/package\": \"\u003c1.3.2\", // anything below 1.3.2 // * | wildcard \"vendor/package\": \"1.3.*\", // \u003e=1.3.0 \u003c1.4.0 // ~ | allows last digit specified to go up \"vendor/package\": \"~1.3.2\", // \u003e=1.3.2 \u003c1.4.0 \"vendor/package\": \"~1.3\", // \u003e=1.3.0 \u003c2.0.0 // ^ | doesn't allow breaking changes (major version fixed - following semver) \"vendor/package\": \"^1.3.2\", // \u003e=1.3.2 \u003c2.0.0 \"vendor/package\": \"^0.3.2\", // \u003e=0.3.2 \u003c0.4.0 // except if major version is 0 } ","date":"2021-11-04","objectID":"/posts/php-web/composer/:1:0","series":null,"tags":["composer"],"title":"composer","uri":"/posts/php-web/composer/#版本说明"},{"categories":["技术"],"content":"Linux 直接发送UDP包 如果往本地UDP端口發送數據，那麼可以使用以下命令： echo \"hello\" \u003e /dev/udp/192.168.1.81/5060 意思是往本地192.168.1.81的5060端口發送數據包hello。 如果往遠程UDP端口發送數據，那麼可以使用以下命令： echo \"hello\" | socat - udp4-datagram:192.168.1.80:5060 意思是往遠程192.168.1.80的5060端口發送數據包 hello 。 远程可以监听对应端口查看： # -l listen -p source-port -4 ipv4 -u udp nc -l -p 5060 -4 -u ps: 先安装 socat ，centos: yum install -y socat​ ","date":"2021-11-04","objectID":"/posts/unixs/linux%E5%8F%91udp%E5%8C%85/:0:0","series":null,"tags":["unix","linux"],"title":"linux发udp包","uri":"/posts/unixs/linux%E5%8F%91udp%E5%8C%85/#"},{"categories":["技术"],"content":" 三大范式 非标准化形式： 主键不能重复；不出现重复记录 字段原子性，不能再分 反例： 联系方式 =》（电话，邮箱） 不能存在部分依赖。 随着主键值的变化，其它列名也必须随之而变化，如果主键是几个列名的组合，其它列名（副键）必须同时被这几个列名影响，少一个的话，不行。 反例： 组件id，价格，供应商id，供应商名称，供应商地址。 同一个组件有可能由不同的供应商提供，故 组件 id 和 供应商 id 组成主键， 价格 和 主键 完全依赖； 供应商名称和地址 只依赖于 供应商 id， 部分依赖 不能存在传递依赖。 副键与副键之间，不能存在依赖关系。 反例： 学号，姓名， 性别，班级，班主任。班主任 受到 班级 的影响，就需要另外 建一张表。 ","date":"2021-11-04","objectID":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/:1:0","series":null,"tags":["mysql"],"title":"Mysql 范式 事务 锁","uri":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/#三大范式"},{"categories":["技术"],"content":" 事务数据库事务（简称:事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的使用是数据库管理系统区别文件系统的重要特征之一。 ","date":"2021-11-04","objectID":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/:2:0","series":null,"tags":["mysql"],"title":"Mysql 范式 事务 锁","uri":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/#事务"},{"categories":["技术"],"content":" 4个特性 原子性 要么做完，要么不做，没有中间停滞环节。 一致性 从一种状态变成另一种状态。开始和结束后，完整性约束没有变化。 隔离性 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行效果。即，每个事务有各自完整的数据空间。 mysql 通过锁机制来保证事务的隔离性。 持久性 事务一旦提交，其结果就是永久性的。 ","date":"2021-11-04","objectID":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/:2:1","series":null,"tags":["mysql"],"title":"Mysql 范式 事务 锁","uri":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/#4个特性"},{"categories":["技术"],"content":" 事务的隔离等级 READ UNCOMMITTED（读未提交）脏读 事务2 读到了 事务1 未提交的数据。 READ COMMITTED （读提交） 不可重复读 事务2 只能读到 事务1 已经提交的数据。是 Oracle 和 SQL Server 的默认隔离级别。 REPEATABLE READ （可重复读） 幻读 事务2 不会读到 事务1 对已有数据的修改，即使事务1的修改 已提交，也就是说，事务2 开始时读到的数据是什么，在事务2 提交前的任意时刻，这些数据的值都是一样的。 mysql 的默认隔离级别。 如果 根据读取数据插入或修改时，与数据库真实数据发生冲突（完整性和一致性），mysql 称为幻读。（如，主键冲突等）。 SERIALIZABLE（序列化） 事务是串行顺序执行的，MySql 的 InnoDB 会给读操作隐式的加一把读共享锁，从而避免了脏读、不可重复读、幻读的问题。 ","date":"2021-11-04","objectID":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/:2:2","series":null,"tags":["mysql"],"title":"Mysql 范式 事务 锁","uri":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/#事务的隔离等级"},{"categories":["技术"],"content":" 锁锁也是数据库管理系统区别文件系统的重要特征之一。锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。 Mysql 的锁其实可以按很多种形式分类: 按加锁机制分,可分为乐观锁与悲观锁. 按兼容性来分,可分为X锁与S锁. 按锁粒度分,可分为表锁,行锁,页锁. 按锁模式分,可分为记录锁, gap锁, next-key锁, 意向锁, 插入意向锁. InnoDB 实现了两种类型的行级锁： 共享锁 （S 锁）： 允许事务读取一行数据。 select * from TableName where … lock in share mode; 独占锁 （X 锁）： 允许事务删除或更新一行数据。 select * from TableName where … for update; S 锁与 S锁 是兼容的，X 锁和其它锁都不兼容。 为了实现多粒度的锁机制，InnoDB 还有两种内部使用的 意向锁 ，由 InnoDB 自动添加，且都是表级别的锁。 意向共享锁 （IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。 意向排他锁 （IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。 ","date":"2021-11-04","objectID":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/:3:0","series":null,"tags":["mysql"],"title":"Mysql 范式 事务 锁","uri":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/#锁"},{"categories":["技术"],"content":" 死锁死锁 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 ","date":"2021-11-04","objectID":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/:3:1","series":null,"tags":["mysql"],"title":"Mysql 范式 事务 锁","uri":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/#死锁"},{"categories":["技术"],"content":" 锁优化建议 合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。 ","date":"2021-11-04","objectID":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/:3:2","series":null,"tags":["mysql"],"title":"Mysql 范式 事务 锁","uri":"/posts/php-web/mysql-%E8%8C%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1-%E9%94%81/#锁优化建议"},{"categories":["技术"],"content":" 一个请求的生命周期","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:1:0","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#一个请求的生命周期"},{"categories":["技术"],"content":" 0. 启动服务 准备工作启动 php-fpm，通信模式， TCP socket， Unix scoket。 PHP-FPM 启动两种进程， master：监控端口、分配任务，管理 worker 进程， worker： 就是 php 的cgi 程序，解释和编译执行 php 脚本。 启动 nginx。载入 ngx_http_fastcgi_module 模块，初始化 FastCGI 执行环境，实现 FastCGI 协议 请求代理。 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:1:1","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#0-启动服务-准备工作"},{"categories":["技术"],"content":" 1. request =\u003e nginxnginx 接受请求，基于 location 配置，选择 handle，即 代理 PHP 的 handle。 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:1:2","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#1-request--nginx"},{"categories":["技术"],"content":" 2. nginx =\u003e PHP-FPMnginx 将请求翻译成 fastcgi 请求。 通过 tcp scoket /unix scoket 发送给 PHP-FPM 的 master 进程 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:1:3","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#2-nginx--php-fpm"},{"categories":["技术"],"content":" 3. PHP-FMP 的 master =\u003e workermaster 分配 worker 执行 php 脚本，没空闲 worker 返回 502。 worker （php-cgi）进程执行 php 超时 返回 504 处理解释返回结果 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:1:4","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#3-php-fmp-的-master--worker"},{"categories":["技术"],"content":" 4. worker =\u003e master =\u003e nginxworker 返回处理结果给 master，关闭连接，等待下一个请求 master 进程返回结果给 nginx nginx 根据 handle 顺序，将响应一步一步返回给客户端 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:1:5","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#4-worker--master--nginx"},{"categories":["技术"],"content":" php解释执行的机制 初始化 ，启动 zend 引擎，加载注册的拓展模块 （php-fpm 启动时） 读取脚本文件，词法分析和语法分析 生成语法树 zend 引擎编译语法树， 生成 opcode 执行 opcode，返回结果 步骤 2-4 每个请求都要执行一次，极大的浪费。 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:2:0","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#php解释执行的机制"},{"categories":["技术"],"content":" opcache将编译好的操作码放入共享内存，提供给其他进程访问。 主要缓存 opcode interned string ， 如注释，变量名 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:3:0","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#opcache"},{"categories":["技术"],"content":" php-fpm 三种运行模式 ondemand 内存优先 php-fpm 启动时候不会创建 worker 进程，链接进来时按需创建 static 静态池 启动时 创建固定数量的 worker 进程，也有1 秒的定时器，统计进程状态 dynamic 服务优先 启动时候创建一部分进程，运行过程中动态调整worker 数量 ps： https://segmentfault.com/a/1190000022549643 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/:4:0","series":null,"tags":["php"],"title":"PHP 和 Nginx 通信","uri":"/posts/php-web/php%E5%92%8Cnginx%E9%80%9A%E4%BF%A1/#php-fpm-三种运行模式"},{"categories":["技术"],"content":" php 假值 与 empty 和 is_null 当 $a 是以下 值时候 (boolean) $a 为假 false： 未设置的变量 var $a; 未初始化 $a 的值 $a = null; false 0 '' ‘0’ [] 以上值 empty() 是均为 true 。 isset() 检测 一个变量设置了，且不为 null ，所以仅仅前 3 条 为 false 。 is_null() 正好与 isset() 相反， 仅仅 前 3 条 为 true 。 gettype() 前3条 ，均返回 null，即 类型 未知。 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["php"],"title":"PHP 基础","uri":"/posts/php-web/php%E5%9F%BA%E7%A1%80/#php-假值-与-empty-和-is_null"},{"categories":["技术"],"content":" php array_map 和 array_walk 的区别相同点 都是利用回调函数对数组中每个元素进行操作。 array_map(callable $callback, $$arr, …$$arr):array array_walk( array \u0026$arr, callable $$callback [,$$userData]) 描述 对数组的每个元素应用回调函数 使用用户子定义函数对每个元素做回调处理 返回值 返回数组，如果回调函数没有返回值 返回 [] 返回 bool ， 成功 true，否则 false 参数顺序 先回调，再数组，再额外数组 先数组，再回调，再用户数据 回调函数参数 只有数组的 value， 且 个数 与 传入的数组一致，即可以转入多个数组 默认 value, key [可选用户数据], 如果要修改原数组的值以引用的方式 (\u0026) 传第一个值 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["php"],"title":"PHP 基础","uri":"/posts/php-web/php%E5%9F%BA%E7%A1%80/#php-array_map-和-array_walk-的区别"},{"categories":["技术"],"content":" php 的魔术方法__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __serialize(), __unserialize(), // 序列化和反序列化 __toString()， __invoke()， // 以函数方式调用一个对象时 $a= new A; $a(1); class A 中的 __invoke($val) 方法将被调用 __set_state()， __clone() // 深度复制时 调用 __debugInfo() ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["php"],"title":"PHP 基础","uri":"/posts/php-web/php%E5%9F%BA%E7%A1%80/#php-的魔术方法"},{"categories":["技术"],"content":" 变量的存储结构众所周知，php 是用 c 语言写的，所以其变量存储也依赖于 c 语言。php 的变量的内部是使用一种 zval 的数据结构来保存的。 // php源码 Zend/zend.h 文件中 typedef struct _zval_struct zval; // ... struct _zval_struct { zvalue_value value; /* 变量的值 */ zend_uint refcount__gc; /* 指向该变量容器的变量(也称符号即symbol)个数 */ zend_uchar type; /* 变量的类型 */ zend_uchar is_ref__gc; /* 是否是引用 默认 false */ }; refcount__gc 为 0 表示没有变量指向这个内存容器， 就可以被释放。 // refcount__gc 举例 $a = 1; // 内存中存在 一个 zval 结构 { value:1; type:integer; refcount__gc:1; is_ref__gc:false } ps: zval 结构的值是 zvalue_value（数据结构） 的，这里说 1, 不准确 $b = $a; // zval 中的 refcount__gc 就加 1， 为 { value:1; type:integer; refcount__gc:2; is_ref__gc:false } unset($b) // zval 中的 refcount__gc 就减 1，为 { value:1; type:integer; refcount__gc:1; is_ref__gc:false } ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:1:0","series":null,"tags":["php"],"title":"PHP 垃圾回收机制","uri":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/#变量的存储结构"},{"categories":["技术"],"content":" 顽固垃圾的产生简单变量 refcount__gc = 0 时，直接释放 zval 内存，没什么问题。 \u003c?php $a = array( 'one' ); $a[] =\u0026 $a; xdebug_debug_zval( 'a' ); 以上将输出： a: (refcount=2, is_ref=1)=array ( 0 =\u003e (refcount=1, is_ref=0)='one', 1 =\u003e (refcount=2, is_ref=1)=... ) 此时 unset($a) ， 引用情况将变成： (refcount=1, is_ref=1)=array ( 0 =\u003e (refcount=1, is_ref=0)='one', 1 =\u003e (refcount=1, is_ref=1)=... ) 尽管 $a 已经被 unset， 但是内存中的数据还在，refcount=1， 不能被清理。 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:2:0","series":null,"tags":["php"],"title":"PHP 垃圾回收机制","uri":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/#顽固垃圾的产生"},{"categories":["技术"],"content":" 清理顽固垃圾php 5.3 引入了新的垃圾清理算法来清理以上垃圾。 具体参考 https://www.php.net/manual/zh/features.gc.collecting-cycles.php 可以这么理解： 对于一个包含环形引用的数组，对数组中包含的每个元素的 zval 进行减1操作，之后如果发现数组自身的 zval 的 refcount 变成了0，那么可以判断这个数组是一个垃圾，对象也类似。 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:0","series":null,"tags":["php"],"title":"PHP 垃圾回收机制","uri":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/#清理顽固垃圾"},{"categories":["技术"],"content":" 配置php 中 GC 默认开启，配置项是 ini 文件 zend.enable_gc 项 。也可以通过 gc_enable() 和 gc_disable()函数来开启和关闭GC。 垃圾分析算法将在节点缓冲区(roots buffer)满了之后启动。缓冲区默认可以放10,000个节点，当然你也可以通过修改Zend/zend_gc.c中的_GC_ROOT_BUFFER_MAX_ENTRIES_ 来改变这个数值，需要重新编译链接PHP。你也可以通过调用gc_collect_cycles()在节点缓冲区未满的情况下强制执行垃圾分析算法。 ","date":"2021-11-04","objectID":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:0","series":null,"tags":["php"],"title":"PHP 垃圾回收机制","uri":"/posts/php-web/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/#配置"},{"categories":["技术"],"content":"过滤器可以用于管道，通过组合，解决实际问题，优雅而强大。 常用过滤器 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:0:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#"},{"categories":["技术"],"content":" catcat name.txt mobile.txt \u003e data # 合并文件 # -n 显示行号 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:1:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#cat"},{"categories":["技术"],"content":" split ：拆分文件split [-d] [-a num] [-l lines] [file [prefix]] split data # 默认每个文件1000行 命名 xaa xab ... # -l 100 : 指定每个文件行数 # -d ：改命名为 00 01 02 # -a 2 ： 命名改为 3 位 aaa aab / 001 002 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:2:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#split-拆分文件"},{"categories":["技术"],"content":" tac：反转文本行的顺序和 cat 类似， 写入标准输出前将文本行反转，适用于日志文件等。 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:3:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#tac反转文本行的顺序"},{"categories":["技术"],"content":" rev：反转字符rev data # data 内容： # 1234 # abcd # 结果如下： # dcba # 4321 rev data | tac # 倒背如流 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:4:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#rev反转字符"},{"categories":["技术"],"content":" head / tail ：从数据开头和末尾选择数据行head [-n lines] tail [-n lines] # 默认 10 行数据 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:5:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#head--tail-从数据开头和末尾选择数据行"},{"categories":["技术"],"content":" 列操作","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:6:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#列操作"},{"categories":["技术"],"content":" colrm ：删除数据列colrm [startcol [endcol]] # 列编号 从 1 开始 # 把 students_old 文件删除 14 列到 20 列后 保存到 student_new 文件中 colrm 14 20 \u003c students_old \u003e students_new ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:6:1","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#colrm-删除数据列"},{"categories":["技术"],"content":" cut ： 抽取数据列 （与 colrm 相反）cut -c list [file ...] # 抽取data中的 14-30 和 42-49 列 cut -c 14-30,42-49 data # 结合其他命令 who | cut -c 1-8 | sort | uniq -c # 定界符分割，如下形式的数据也可以抽取 张三:男:23岁 王麻子:女:105岁 # 抽取按照 ':' 分割后的， 第 1 和第 3 列数据 cut -f 1,3 -d ':' data # 可以删除选项的空格 如 cut -f1,3 -d':' data # ps 如果一行没有定界符，默认返回整行，如果想抛弃这样的行，可以使用 -s ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:6:2","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#cut--抽取数据列-与-colrm-相反"},{"categories":["技术"],"content":" paste 组合数据列paste [-d char...] [file ...] # 合并三个文件 paste file1 file2 file3 # 使用定界符 | paste -d '|' file1 file2 # 定界符轮换使用 paste -d '|\u0026' file1 file2 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:6:3","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#paste-组合数据列"},{"categories":["技术"],"content":" 比较文件","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:7:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#比较文件"},{"categories":["技术"],"content":" cmp ：逐字节比较cmp file1 file2 # 相同的话就 不做任何处理 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:7:1","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#cmp-逐字节比较"},{"categories":["技术"],"content":" comm ： 比较有序文本文件comm [-123] file1 file2 # 第一列 仅输出第一个文件有的行 # 第二列 仅输出第二个文件有的行 # 第三列 输出两个文件都有的行 # -1 -2 -3 表示抑制某一列的输入 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:7:2","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#comm--比较有序文本文件"},{"categories":["技术"],"content":" diff / sdiff： 比较无序文件diff file1 file2 # 默认 有指示符 （c, d, a）和行号构成 # c 代表改变 d 代表删除 a 代表增加 # 中间 ------- 分割 # 文件2 新增两行 0a1,2 \u003e 沁园春·雪 \u003e # 第5 第7行不一致 5c7 \u003c 须晴日5，看红装素裹，分外妖娆6。 --- \u003e 须晴日，看红装素裹，分外妖娆。 # 文件2 删除了一行 10d11 \u003c 俱往矣，数风流人物，还看今朝。 # 选项 # -c 和 -u 可以显示 2 行上下文信息 # -C3 -U3 可以显示 3 行上下文信息 # 并列比较 等价的 diff -y file1 file2 sdiff file1 file2 # 选项 -l 相同的行只显示左侧的 -s 不显示相同的行 -w 50 指定列宽度 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:7:3","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#diff--sdiff-比较无序文件"},{"categories":["技术"],"content":" 统计和格式化","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:8:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#统计和格式化"},{"categories":["技术"],"content":" nl ：创建行号nl [-v start] [-i increment] [-b a] [-n ln|rn|rz] [file ...] # start 起始号 # increment 增量 # 默认 nl 不对空行编号， -b a （all lines 所有行） # ln=左对齐，没有前导 0 # rn=右对齐，没有前导 0 # rz=右对齐，有前导 0 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:8:1","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#nl-创建行号"},{"categories":["技术"],"content":" wc : 单词统计wc [-clLw] [file ...] # wc 默认输出三个数字：行数（line），单词数（word），字符数（char），LWC （look at Women Carefully） # -clw 显示指定列 # -L 显示最长的行 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:8:2","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#wc--单词统计"},{"categories":["技术"],"content":" expand: 将制表符转换成空格expand [-i] [-t size | -t list] [file...] # -i 只转换开头的制表符 # -t size 默认size等于8 ，每8个位置一个制表符 # -t list 指定制表符位于特定的位置，0指第一个位置，如 expand -t 7,15,21 data ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:8:3","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#expand-将制表符转换成空格"},{"categories":["技术"],"content":" unexpand : 将空格转换成制表符unexpand [-a] [-t size | -t list] [file ...] # 默认只替换开头的空格 # -a 标识替换所有空格 # -t 的参数和 expand 一致 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:8:4","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#unexpand--将空格转换成制表符"},{"categories":["技术"],"content":" fold: 长行分成短行fold [-s] [-w width] [file ...] # 默认 80 字符每行， # -w width 可以重新指定宽度 # -s 不从中间分割单词 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:8:5","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#fold-长行分成短行"},{"categories":["技术"],"content":" fmt：将段落中的各行连接起来fmt [-su] [-w width] [file...] # -w width 行宽 # -u 统一间距，单词间有多个空格，减少，只保留一个 # -s 仅拆分长行，而不连接短行 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:8:6","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#fmt将段落中的各行连接起来"},{"categories":["技术"],"content":" 选取、排列、组合与变换","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:0","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#选取排列组合与变换"},{"categories":["技术"],"content":" grep：选取包含特定模式的行grep [-cilLnrsvwx] pattern [file...] # -c 统计数量, ls -F 会在子目录会添加/字符，以下可以统计反斜线的数量 即子目录的数量 ls -F /etc | grep -c \"/\" # 统计总数 ls /etc | wc -l # -i 忽略大小写 # -n 显示行号 grep -in pizza food-list.md # 忽略大小写查找出含 pizza 的行并显示行号 # -l 不显示包含的行，而显示包含的文件名 查找哪个班有小明同学 grep -il xiaoming class1_names class2_names class3_names # output class1_names # -L 与 -l相反，显示不包含的文件 grep -iL xiaoming class1_names class2_names class3_names # output class2_names class3_names # -w 单词完整匹配， grep now data # 会匹配 now，也会匹配 know grep -w now # 只匹配 now # -v 取反，选取不包含的模式的所有行 grep -v done todo_list # 列出所有未完成的项目 grep -cv done todo_list # 统计为完成的项目数目 # -x 查找占用整行的 grep -x \"hello world\" data # 返回 由 'hello world' 构成的行 # -r 递归搜索目录树 grep -r initialize admin # 搜索admin目录及子目录文件中是否有单词 “inttialize” # -s 抑制错误显示 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:1","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#grep选取包含特定模式的行"},{"categories":["技术"],"content":" look：查找以特定模式开头的所有单词look [-df] pattern file # look 搜索以字母顺序排列的数据，并以特定的模式开头的行 # 因为 look 使用二分法，搜索数据，要求同时获取所有数据，故只能再管道的开头使用数据，不能再管道中间使用 # -d 只考虑字母和数字 # -f 忽略大小写 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:2","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#look查找以特定模式开头的所有单词"},{"categories":["技术"],"content":" sort : 排序数据sort [-dfnru] [-o outfile] [infile...] # 排序数据和查看数据是否排序 # 排序后保存到原文件时，这是错误的 重定向输出时， shell 运行命令前会清空输出的文件，（除非设置了变量 noclobber ） sort names \u003e names # wrong sort -o names names # right # -d 只查看字母、数字和空白符，如果数据中有妨碍排序的标点时，使用此选项 # -f 忽略大小写 # -n 识别开头的数字，按数字大小排序 # -r 倒序 # -u 唯一，相同的行，只留下一行 sort -c[u] [file] # -c 检查数据是否有序，无序输出，开始无序的行，有序无消息（没有消息就好的消息） # -u 配合-c使用，可以确保数据是有序， 唯一 # 排序规则：取决于你系统的字符组织方式 # 早期使用 ASCII 顺序， （SNUL） 空格 数字 大写字母 小写字母 # 现在 使用环境变量 LC_COLLATE 指定使用哪一种排序 c 是 ASCII locale # 可以查看所有区域设置的当前值 locale -a # 查看自己的系统支持哪些区域设置 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:3","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#sort--排序数据"},{"categories":["技术"],"content":" uniq: 查找重复行uniq 可以做四个不同的任务 消除重复行 uniq 选取重复行 uniq -d 选取唯一行 uniq -u 统计重复行数量 uniq -c uniq [-cdu] [infile] [outfile] # 输入必须是有序的，即重复行是连续的 # -d 只查看重复行 # -u 只查看唯一行 # -c 统计唯一行的数量 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:4","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#uniq-查找重复行"},{"categories":["技术"],"content":" jion: 基于特定字段的值将两个有序文件组合在一起join [-i] [-a1|-v1] [-a2|v2] [-1 field1] [-2 field2] file1 file2 # eg: cat file1 111 张三 222 李四 333 王五 999 孙悟空 cat file2 111 10086 222 10010 333 110 444 120 555 119 # join file1 file2 111 张三 10086 222 李四 10010 333 王五 110 # join -a1 file1 file2 111 张三 10086 222 李四 10010 333 王五 110 999 孙悟空 # join -v1 file1 file2 999 孙悟空 # 如上， join 关联类似于关系数据库的的join， # 没-a选项时 内关联 inner join ，只输出关联字段匹配的行 # -a1 -a2 时还输出关联字段不匹配的行 # -v1 -v2 只查看不匹配的行 # -i 忽略大小写 # join 默认使用的是 文件的第一个字段 可以使用 -1 -2 指定不同的字段 # 特别注意： join 使用的有序数据 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:5","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#jion-基于特定字段的值将两个有序文件组合在一起"},{"categories":["技术"],"content":" tsort: 以偏序创建全序tsort [file] # 偏序：只指定了一部分活动的顺序 # file 中的每一行必须包含一堆空白符分割的字符串 每个字符串代表一个偏序 # 最终结果生成一个完整序列 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:6","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#tsort-以偏序创建全序"},{"categories":["技术"],"content":" strings: 二进制文件中搜索","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:7","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#strings-二进制文件中搜索"},{"categories":["技术"],"content":" tr: 转换字符 转换字符 ：小写转大写，制表符转空格 挤压字符：连续数字 替换为 “X” ,多个空格转换为一个 删除指定字符：删除所有指标符 tr [-cds] [set1 [set2]] # 只能从标准输入接收数据，不能从文件读取，如果要从文件读取请重定向 tr a A \u003c old \u003e new # old 文件中的 a 替换成 A 了, 并写入 new 文件 tr abc ABC \u003c old \u003e new # abc 替换 ABC # 以下情况，第二组最后一个字符是重复的，等价 tr abcd Ax tr abcd Axxxx # 特殊字符需要引用或转义 tr ':;?' \\. # :;? 均替换成了 . # 支持范围 tr A-Z a-z tr 0-9 A-J # 缩写 (预定义字符) tr [:upper:] [:lower:] # 大写转小写 tr [:diggit:] A-J # 不可显示的字符 (转义 or ASCII码的值) tr '\\r' '\\n' \u003c macfile \u003e unixfile # 回车符转换为换行符 tr '\\015' '\\012' \u003c macfile \u003e unixfile tr '\\t' ' ' # 制表符转换为空格 # ********* 挤压 ********* tr -s [:digit:] X # 数字转换成 x tr -s ' ' ' ' # 挤压空格 # **** 删除 **** tr -d '()' # **** 补集 ***** tr -c ' \\n' x \u003c olddata \u003e newdata # hello world ==\u003e xxxxx xxxxx eg: 统计两个文件的单词数 cat greek roman | tr -cs [:alpha:]\\' \"\\n\" | sort -fu | wc -l ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:8","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#tr-转换字符"},{"categories":["技术"],"content":" sed: 非交互式文本编辑(提前设计命令，命令发给程序，自动执行)(流编辑器)sed [-i] command | -e command ... [f] -i # 直接修改原文件 # 命令 # a 行后插入， 多行的话 末尾\"\\\" # i 行前插入， 多行 \"\\\" # c 替换 # d 删除 # p 打印 # s 替换 可用正则表达式 # 查看某一行 sed -n '1003,1p' data.txt # 修改某一行 sed -i '1003c new line content' data.txt # 将 11 修改为 12，g 代表一行的所有 sed -i 's/11/12/g' xxx.log sed -i 's/11/12/g' xxx.log # 修改每行第一个 11 ","date":"2021-11-04","objectID":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/:9:9","series":null,"tags":["unix","linux"],"title":"Unix 过滤器","uri":"/posts/unixs/unix-%E8%BF%87%E6%BB%A4%E5%99%A8/#sed-非交互式文本编辑提前设计命令命令发给程序自动执行流编辑器"},{"categories":["技术"],"content":" 移动光标 - 光标移动到上一行开头 + 或 \u003creturn\u003e 光标移动到下一行开头 0 当前行开头 $ 当前行末尾 ^ 当前行第一个非空字符 w 下一个单词的词首 W 忽略标点 e 下一个单词的词尾 E … b 上一个单词的词首 B … ( 移动到上一个句子 ) 下一个句子 { 上一个段落 } 下一个段落 H 移动到屏幕顶部 M 屏幕中间 L 最后一行 数字组合 10w 向后移动10个单词 20j 向下移动20行 3{ 向后移动3段 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:1:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#移动光标"},{"categories":["技术"],"content":" 在编辑缓冲区移动^F 向下移动一屏 ^B 向上移动一屏 ^D 向下移动半屏 ^U 向上移动半屏 6^F 向下移动6屏 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:2:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#在编辑缓冲区移动"},{"categories":["技术"],"content":" 跳转到前一位置`` 或 '' 返回到前一个位置 ma 标识当前行名称为 “a” `a 或 'a 即可跳转到标记开头 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:3:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#跳转到前一位置"},{"categories":["技术"],"content":" 搜索模式/ 或者 ? 加要搜索的内容 / 向前搜索 ? 向后搜索 n 下一个 N 上一个 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:4:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#搜索模式"},{"categories":["技术"],"content":" 行号:set number 显示行号 :set nonumber 隐藏行号 100G 跳转到100行 gg 第一行 G 末尾一行 :100 跳转到100行 :$ 最后一行 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:5:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#行号"},{"categories":["技术"],"content":" 插入文本i 光标前插入 a 光标后插入 I 当前行开头插入 A 当前行结尾插入 o 当前行下面插入一行 O 当前行上面插入一行 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:6:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#插入文本"},{"categories":["技术"],"content":" 修改文本ra 把光标上的单个字符修改为a Rxxx\u003cEsc\u003e R会切换到输入模式，键入的字符将被替换当前行的一个字符， 返回命令模式 s (substitute, 替换) 使用多个字符替换光标上的字符 C 替换当前光标位置到本行结尾所有字符 S 或 cc 替换整行 cmove 从光标处替换到 move 所给出的位置处 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:7:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#修改文本"},{"categories":["技术"],"content":" 替换文本:s/pattern/replace/gc 当前行上替换 默认替换第一个匹配项，g(global 全局)，替换本行所有匹配项； c(confirm, 确认) 替换前需要你同意 :45s/pattern/replace/ 替换57行的第一个匹配项 :10,50s/pattern/replace/ 10到50行 :.,$s/s/pattern/replace/g 当前行都结尾最后一行 . 代表当前行, $ 代表结尾最后一行 :%s/pattern/replace/g 替换所有行 % 代表所有行 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:8:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#替换文本"},{"categories":["技术"],"content":" 删除文本x 删除当前光标处字符 X 删除光标左边的一个字符 D 删除当前光标到本行结尾的字符 dmove 删除当前光标都 move 所在位置的字符 dd 删除当前行 :12d 删除12行 等价于 12dd :12,34 删除12到34行 eg: dw 删除一个单词 d10w 删除10个单词 d10W 删除10个单词（忽略标点） db 向后删除1个单词 d2) 删除2个句子 d3} 删除5个段落 dG 删除到结尾 dgg 删除到开头 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:9:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#删除文本"},{"categories":["技术"],"content":" 撤销或重复改变u 撤销上一条命令 U 恢复当前行 . 重复上一命令对编辑缓冲区的修改 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:10:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#撤销或重复改变"},{"categories":["技术"],"content":" 恢复删除每删除一行或多行文本的时，vi 都将内容保存在一个特殊的存储区里，编号缓冲区。vi 有 9 个缓冲区。 任何时候，都可以将编号缓冲区的内容插入到编辑缓冲区里。 \"1p 或 \"2P 即可插入 p 在当前行下，P 在当前行上 tip: 编号缓冲区只存储删除的行，单个字符或多个字符不会保存在编号缓冲区 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:11:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#恢复删除"},{"categories":["技术"],"content":" 移动文本vi 总有一个无名缓冲区，为上一次删除保存了一份副本。任何时候可以使用 p 或 P 将缓冲区的内容复制到编辑缓冲区中。 xp 调换两个字母的位置 deep 调换两个单词（光标处于第一个单词的左边） ddp 调换两行 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:12:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#移动文本"},{"categories":["技术"],"content":" 复制文本分3步 y、yy 或 Y 命令将文本由编辑缓冲区复制到无名缓冲区，但不删除原始文本。 光标移动到插入到希望插入文本的位置。 使用 p 或 P 插入。 y (yank 接出) 和 d 命令工作方式一样 yw 接出一个单词 y10W 10个单词 yb 向前接出一个单词 y2) 接出2个句子 y5} 接出5个段落 yy 接出1行 12yy 接出12行 等价于 12Y y$ 接出到行尾部 y0 接出到行开头 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:13:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#复制文本"},{"categories":["技术"],"content":" 改变字母大小写~ 改变当前字母大小写，并向后移动一个位置 7~ 重复7次~ ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:14:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#改变字母大小写"},{"categories":["技术"],"content":" 设置选项:set [no]option... :set option[=value]... # 显示输入提醒 :set showmode :set noshowmode # 显示行号 :set number :set nonumber # 选项是变量的 :set tabstop=4 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:15:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#设置选项"},{"categories":["技术"],"content":" 显示选项:set [option[?]... | all] # 显示所有选项的值 :set all :set number? ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:16:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#显示选项"},{"categories":["技术"],"content":" 键入过程自动换行:set wrapmargin=n / :set wm=n n 是从右边边缘算起开始换行的位置 :set wm=l 文本尽可能的长 :set wm=0 关闭自动换行 :set autoindent 文本自动缩进 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:17:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#键入过程自动换行"},{"categories":["技术"],"content":" 分隔和连接行r\u003cReturn\u003e 长行分割短行, r 可以将一个字符替换成另外一个字符，此处将 空格符 替换成 换行符 J 可以将当前行和下一行合并到一个长行 （默认会在单词之间插入一个空格，句子行尾插入两个空格） 3J 合并一下三行 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:18:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#分隔和连接行"},{"categories":["技术"],"content":" 复制和移动行指定行号的复制和移动可以使用 ex 命令 :co (copy, 复制) :m (move , 移动)。 :_x[,y]co_z x,y,z 代表行号 :_x[,y]m_z :5co10 复制5行插入到第10行下面 :6,9co15 复制第6行至第9行，插入到第15行下面 :5m10 移动第5行，插入到第10行下面 4,8m12 移动第4行至第9行，插入到第12行下面 和其他 ex 命令一样 . 代表当前行，$ 代表最后一行： :1,.m$ 将第1行至当前行，移动到编辑缓冲区末尾 :.,$m0 将当前行至末尾，移动到编辑缓冲区开头 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:19:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#复制和移动行"},{"categories":["技术"],"content":" 输出 shell 命令 :! + 希望运行的命令，vi 将命令发送给 shell 执行，当命令结束后吗，控制将返回 vi。 :!date 输出日期 :!! 重复上一条命令 有时候希望输入 不止1条 shell 命令。这时候可以启动一个 新的shell 。 :sh 启动一个新的 shell 副本，^D 或 输入 exit 命令后返回 vi 中。 :!bash 启动一个 Bash shell ，:!tcsh 启动一个 Tcsh shell ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:20:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#输出-shell-命令"},{"categories":["技术"],"content":" 将文件的数据插入编辑缓冲区:[line]r file line 行号，file 文件名称 :10r info 将 info 的文件内容插入到第 10 行之后 :0r info 0 表示开头 :$r info $ 表示结尾 r info 省略了行号，vi 将数据插入到当前行之后 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:21:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#将文件的数据插入编辑缓冲区"},{"categories":["技术"],"content":" 将shell 命令输出插入到编辑缓冲区:r !ls 将 ls 的结果插入到编辑缓冲区 :0r !date 在第一行插入当前时间和日期 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:22:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#将shell-命令输出插入到编辑缓冲区"},{"categories":["技术"],"content":" 使用程序处理数据使用 ! 和 !! 命令可以将编辑缓冲区的行发送给另一个程序。该程序的输出将替换原始行。 5!!sort 排序当前光标的下5行数据 10!!fmt 从当前行开始格式化10行 ! + 光标移动命令 + 程序名称。 !}fmt 格式化当前行至段落末尾之间的文本 gg、1G +!Gfmt 格式化整个编辑缓冲区 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:23:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#使用程序处理数据"},{"categories":["技术"],"content":" 将数据写入文件:w 数据写入原始文件 :w file 将数据写入新文件 :w! file 覆盖已有文件 :w\u003e\u003e file 追加数据到文件 :10w! file 将第10行数据写入文 :10,20w \u003e\u003e file 将10到20行数据追加到文件里 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:24:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#将数据写入文件"},{"categories":["技术"],"content":" 切换文件编辑文件时，不必退出重启 vi ，切换到另一个新文件。确保之前编辑缓冲区内容的保存（:w）。 :e document 编辑指定文件 :e! 重新编辑当前文件，忽略自动检查，即放弃未保存的修改 :e! file 编辑指定文件，忽略自动检查 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:25:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#切换文件"},{"categories":["技术"],"content":" 使用缩写为经常使用的单词或表达式，创建缩写。 :ab [short long] short 是缩写，long是对应的原文 :ab puf public function 单独键入 puf 时，vi 将会自动转换成 public function :una puf 删除缩写 :ab 查看目前所有缩写列表 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:26:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#使用缩写"},{"categories":["技术"],"content":" 宏:map 可以创建单字符命令,即宏(macro). :map [x commands] x 是单个字符, commands 是 vi 或 ex 命令. :map X dd 创建一个 X 的宏, 这个宏删除当前的行。 :map * I/* ^V\u003cEsc\u003eA */^V\u003cEsc\u003e 创建 * 的宏，将该行用 /* 和 */ 包裹起来, 即注释掉. :map 显示所有的宏列表 :unmap X 移除宏 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:27:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#宏"},{"categories":["技术"],"content":" 初始化文件vi 或 vim 启动时, 会在 home 目录查找初始化文件. 如果存在就读取并执行查找到的任何 ex 命令. vi 的初始化文件名为 .exrc (rc 代表 ‘run commands’) . vim 的初始化文件名为 .vimrc vim 首先查找 .vimrc, 如果不存在 , 则查找 .exrc . 如果同时存在, vim 只会读取 .vimrc 文件. 初始化文件, \" 字符开头的将被忽略, 可以作为注释. \" ====================== \"sample vi/vim init file \" ======================= \" \" 1. options set autoindent set compatible set ignorecase set showmatch set showmode set wrapmargin=6 \" \" 2. abbreviation ab puf public function ab prf private function \" \" 3. macros map K deep map X dd \" \" 4. shell commands !date; sleep 2 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:28:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#初始化文件"},{"categories":["技术"],"content":" 使用两个初始化文件vi/vim 启动时, 会在执行 home 目录的初始化文件. 然后检查 exrc 选项的状态. 如果选项打开, 那么程序将在工作目录（即当前目录）查找第二个初始化文件。 通过这种方式，可是使各个目录都有自己的初始化文件，从而组织各个文件。 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:28:1","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#使用两个初始化文件"},{"categories":["技术"],"content":" vim 增强内容 屏幕拆分 多级撤销 支持鼠标 GUI 命令行历史 命令行补全 文件名补全 搜索历史 语法高亮 高亮显示：选取文本行、文本块，然后再对文本进行操作 多缓冲区 支持宏：记录、修改和运行宏的工具 内置脚本 自动命令：自动执行的预定义命令 ","date":"2021-11-04","objectID":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/:29:0","series":null,"tags":["unix","linux","vi"],"title":"Vi 命令一览","uri":"/posts/unixs/vi-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/#vim-增强内容"},{"categories":["技术"],"content":" 镜像相关","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#镜像相关"},{"categories":["技术"],"content":" 列出镜像docker image ls 无仓库名的是悬空镜像，docker image ls -f dangling=true 查看悬空镜像， docker image prune 删除悬空镜像。 该命令默认，仅仅显示顶层镜像，docker image ls -a , 可以显示中间层镜像。 过滤参数 // 指定仓库名 docker image ls ubuntu // 指定仓库名和标签名 docker image ls ubuntu:18.04 // --filter 简写 -f 过滤 docker image ls -f since=mongo:3.2 docker image ls -f label=com.example.version=0.1 docker image ls -f dangling=true 显示格式 docker image ls -q docker image ls --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\" --filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见。 ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#列出镜像"},{"categories":["技术"],"content":" 删除镜像docker image rm [选项] \u003c镜像1\u003e [\u003c镜像2\u003e ...] 镜像标识可以是 长id，短id，镜像名，镜像名：标签等。 Untagged 和 Deleted，untagged 表明镜像和删除标签的关联已经被取消，可能还有其余的标签在镜像上，所有镜像没有被删除。当镜像上的所有标签都被删除后，则触发 delete 行为。 与 docker image ls -q 命令的配合 // 删除所有仓库名为 redis 的镜像 docker image rm $(docker image ls -q redis) // 删除所有在 mongo:3.2 之前的镜像 docker image rm $(docker image ls -q -f before=mongo:3.2) ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#删除镜像"},{"categories":["技术"],"content":" 容器相关","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#容器相关"},{"categories":["技术"],"content":" 启动 基于镜像新建一个容器并启动 docker run ubuntu:18.04 // -t 让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上, -i 则让容器的标准输入保持打开。 docker run -t -i ubuntu:18.04 检查本地是否存在指定的镜像，不存在就从 registry 下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 将一个终止（exited）状态的容器重新启动 // 传入容器id 即可 docker container start [options] containerID ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#启动"},{"categories":["技术"],"content":" 容器列表// 获取正在运行的容器 docker container ls // 获取所有容器 docker container ls -a ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#容器列表"},{"categories":["技术"],"content":" 停止与重启// 停止 docker container stop containerID // 重启 docker container restart containerID ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:3","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#停止与重启"},{"categories":["技术"],"content":" 进入容器-d 参数运行容器时候，容器启动后会进入后台。 // 方式1 ， ps：如果在 stdin 中 exit，会导致容器的停止 docker attach containerID // 方式2 ， ps： exit 不会导致容器停止 docker exec [options] containerID command ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:4","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#进入容器"},{"categories":["技术"],"content":" 查看容器信息docker inspect [OPTIONS] NAME|ID [NAME|ID...] 数据卷 信息在 “Mounts” Key 下面 ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:5","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#查看容器信息"},{"categories":["技术"],"content":" 导出和导入导出 // 导入容器快照到本地文件 docker export 7691a814370e \u003e ubuntu.tar 导入 // 从容器快照导入为镜像 cat ubuntu.tar | docker import - test/ubuntu:v1.0 docker image ls // 会显示 test/ubuntu:v1.0 镜像 // 通过 url 导入 docker import http://example.com/exampleimage.tgz example/imagerepo docker load 也可以导入镜像存储文件到本地镜像库，区别在于： docker import 将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），可以重新指定标签等元数据信息。 docker load 将保存镜像的完整记录，体积也要大。 ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:6","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#导出和导入"},{"categories":["技术"],"content":" 删除// 删除一个处于终止状态的容器, -f 可以删除一个运行中的容器 docker container rm [options] containerID // 清理掉所有处于终止状态的容器 docker container prune ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:7","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#删除"},{"categories":["技术"],"content":" 数据管理","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#数据管理"},{"categories":["技术"],"content":" 数据卷数据卷是可以一个或多个容器使用的特殊目录，它绕过了 UFS ， 可以提供很多特性： 容器间共享和重用 对数据卷的修改会立即生效 对数据卷的更新，不影响镜像 容器删除后，数据卷还会存在 创建数据卷docker volume create my-vol 查看所有数据卷docker volume ls // 查看特定数据卷信息 docker volume inspect my-vol 启动一个挂载有数据卷的容器 docker run -d -p --name \\ # -v my-vol:/usr/share/nginx/html \\ --mount source=my-vol,target=/usr/share/nginx/html \\ nginx:alpine 删除数据卷docker volume rm my-vol // 删除容器时一起删除 docker container rm -v containerID // 批量删除无主的数据卷 docker volume prune ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#数据卷"},{"categories":["技术"],"content":" 数据卷数据卷是可以一个或多个容器使用的特殊目录，它绕过了 UFS ， 可以提供很多特性： 容器间共享和重用 对数据卷的修改会立即生效 对数据卷的更新，不影响镜像 容器删除后，数据卷还会存在 创建数据卷docker volume create my-vol 查看所有数据卷docker volume ls // 查看特定数据卷信息 docker volume inspect my-vol 启动一个挂载有数据卷的容器 docker run -d -p --name \\ # -v my-vol:/usr/share/nginx/html \\ --mount source=my-vol,target=/usr/share/nginx/html \\ nginx:alpine 删除数据卷docker volume rm my-vol // 删除容器时一起删除 docker container rm -v containerID // 批量删除无主的数据卷 docker volume prune ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#创建数据卷"},{"categories":["技术"],"content":" 数据卷数据卷是可以一个或多个容器使用的特殊目录，它绕过了 UFS ， 可以提供很多特性： 容器间共享和重用 对数据卷的修改会立即生效 对数据卷的更新，不影响镜像 容器删除后，数据卷还会存在 创建数据卷docker volume create my-vol 查看所有数据卷docker volume ls // 查看特定数据卷信息 docker volume inspect my-vol 启动一个挂载有数据卷的容器 docker run -d -p --name \\ # -v my-vol:/usr/share/nginx/html \\ --mount source=my-vol,target=/usr/share/nginx/html \\ nginx:alpine 删除数据卷docker volume rm my-vol // 删除容器时一起删除 docker container rm -v containerID // 批量删除无主的数据卷 docker volume prune ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#查看所有数据卷"},{"categories":["技术"],"content":" 数据卷数据卷是可以一个或多个容器使用的特殊目录，它绕过了 UFS ， 可以提供很多特性： 容器间共享和重用 对数据卷的修改会立即生效 对数据卷的更新，不影响镜像 容器删除后，数据卷还会存在 创建数据卷docker volume create my-vol 查看所有数据卷docker volume ls // 查看特定数据卷信息 docker volume inspect my-vol 启动一个挂载有数据卷的容器 docker run -d -p --name \\ # -v my-vol:/usr/share/nginx/html \\ --mount source=my-vol,target=/usr/share/nginx/html \\ nginx:alpine 删除数据卷docker volume rm my-vol // 删除容器时一起删除 docker container rm -v containerID // 批量删除无主的数据卷 docker volume prune ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#删除数据卷"},{"categories":["技术"],"content":" 挂载主机目录","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:2","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#挂载主机目录"},{"categories":["技术"],"content":" 其他","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#其他"},{"categories":["技术"],"content":" 查看镜像容器和数据卷所占体积docker system df ","date":"2021-11-04","objectID":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:1","series":null,"tags":["docker"],"title":"容器常用命令","uri":"/posts/%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#查看镜像容器和数据卷所占体积"},{"categories":["技术"],"content":" 概述控制反转**（Inversion of Control, IoC）**，是面向对象编程的一种设计原则，目的是降低代码耦合。常见方式有 依赖注入 （Dependence Injection, DI） 和 依赖查找 （Dependency Lookup） 。 ","date":"2021-11-04","objectID":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/:1:0","series":null,"tags":["设计模式"],"title":"依赖注入","uri":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/#概述"},{"categories":["技术"],"content":" 技术描述Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。 采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。 ","date":"2021-11-04","objectID":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/:2:0","series":null,"tags":["设计模式"],"title":"依赖注入","uri":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/#技术描述"},{"categories":["技术"],"content":" 实现方式依赖注入有如下实现方式： 基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。 基于 set 方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。 ","date":"2021-11-04","objectID":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/:3:0","series":null,"tags":["设计模式"],"title":"依赖注入","uri":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/#实现方式"},{"categories":["技术"],"content":" Ioc 容器不管是哪一种实现，依赖单元的实例化代码是一个重复、繁琐的过程，且当系统很复杂的时候，依赖嵌套，前后关系的处理将很麻烦。所以 IoC 容器 被发明出来了。IoC Container提供了动态地创建、注入依赖单元，映射依赖关系等功能，减少了许多代码量。 ","date":"2021-11-04","objectID":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/:4:0","series":null,"tags":["设计模式"],"title":"依赖注入","uri":"/posts/php-web/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/#ioc-容器"},{"categories":["技术"],"content":" RESTful 接口 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 以下通过 kibanan 操作。 ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:1:0","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#restful-接口"},{"categories":["技术"],"content":" 基本 curd 操作","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:0","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#基本-curd-操作"},{"categories":["技术"],"content":" 新增# post vdong/_doc/\u003cid\u003e ,不写id会自动生成随机的 _id POST vdong/_doc { \"name\": \"vodng\", \"age\": 23, \"sex\":\"男\" } GET vdong/_doc/t1pqInwB9bbxQEztANxo ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:1","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#新增"},{"categories":["技术"],"content":" 查看GET vdong/_doc/t1pqInwB9bbxQEztANxo // 查看 id 为 1 的文档是否存在 HEAD vdong/_doc/1 // 查看索引是否存在 HEAD vdong // 获取 vdong 索引文档个数 GET vdong/_count ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:2","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#查看"},{"categories":["技术"],"content":" 修改// 需要完整资源信息 PUT vdong/_doc/12 { \"name\": \"栋\", \"age\": 23, \"sex\":\"男\" } // 不需要完整资源 POST vdong/_update/12 { \"doc\": { \"name\": \"ss\" } } 宽松的修改// id 1002 的如果不存在，不会报错, 会新增一个文档 POST vdong/_update/1002 { \"doc\": { \"name\": \"ss\" }, \"doc_as_upsert\": true } 查询并修改// 查询并修改 POST vdong/_update_by_query { \"query\":{ \"match\": { \"name\": \"ccc\" } }, \"script\":{ \"source\": \"ctx._source.age=params.age;ctx._source.sex=params.sex\", \"lang\": \"painless\", \"params\": { \"age\":77, \"sex\":\"女\" } } } // 处理中文字段 POST vdong_cn/_update_by_query { \"query\":{ \"match\": { \"姓名\": \"ss\" } }, \"script\":{ \"source\": \"ctx._source[\\\"年纪\\\"]=params[\\\"年纪\\\"]\", \"lang\": \"painless\", \"params\": { \"年纪\":6 } } } // ctx['_op'] 来删除文档 POST vdong_cn/_update_by_query { \"query\":{ \"match\": { \"姓名\": \"ss\" } }, \"script\":{ \"source\": \"\"\" if(ctx._source[\"年纪\"]\u003c34){ ctx.op = 'delete' } \"\"\" } } ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:3","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#修改"},{"categories":["技术"],"content":" 修改// 需要完整资源信息 PUT vdong/_doc/12 { \"name\": \"栋\", \"age\": 23, \"sex\":\"男\" } // 不需要完整资源 POST vdong/_update/12 { \"doc\": { \"name\": \"ss\" } } 宽松的修改// id 1002 的如果不存在，不会报错, 会新增一个文档 POST vdong/_update/1002 { \"doc\": { \"name\": \"ss\" }, \"doc_as_upsert\": true } 查询并修改// 查询并修改 POST vdong/_update_by_query { \"query\":{ \"match\": { \"name\": \"ccc\" } }, \"script\":{ \"source\": \"ctx._source.age=params.age;ctx._source.sex=params.sex\", \"lang\": \"painless\", \"params\": { \"age\":77, \"sex\":\"女\" } } } // 处理中文字段 POST vdong_cn/_update_by_query { \"query\":{ \"match\": { \"姓名\": \"ss\" } }, \"script\":{ \"source\": \"ctx._source[\\\"年纪\\\"]=params[\\\"年纪\\\"]\", \"lang\": \"painless\", \"params\": { \"年纪\":6 } } } // ctx['_op'] 来删除文档 POST vdong_cn/_update_by_query { \"query\":{ \"match\": { \"姓名\": \"ss\" } }, \"script\":{ \"source\": \"\"\" if(ctx._source[\"年纪\"]\u003c34){ ctx.op = 'delete' } \"\"\" } } ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:3","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#宽松的修改"},{"categories":["技术"],"content":" 修改// 需要完整资源信息 PUT vdong/_doc/12 { \"name\": \"栋\", \"age\": 23, \"sex\":\"男\" } // 不需要完整资源 POST vdong/_update/12 { \"doc\": { \"name\": \"ss\" } } 宽松的修改// id 1002 的如果不存在，不会报错, 会新增一个文档 POST vdong/_update/1002 { \"doc\": { \"name\": \"ss\" }, \"doc_as_upsert\": true } 查询并修改// 查询并修改 POST vdong/_update_by_query { \"query\":{ \"match\": { \"name\": \"ccc\" } }, \"script\":{ \"source\": \"ctx._source.age=params.age;ctx._source.sex=params.sex\", \"lang\": \"painless\", \"params\": { \"age\":77, \"sex\":\"女\" } } } // 处理中文字段 POST vdong_cn/_update_by_query { \"query\":{ \"match\": { \"姓名\": \"ss\" } }, \"script\":{ \"source\": \"ctx._source[\\\"年纪\\\"]=params[\\\"年纪\\\"]\", \"lang\": \"painless\", \"params\": { \"年纪\":6 } } } // ctx['_op'] 来删除文档 POST vdong_cn/_update_by_query { \"query\":{ \"match\": { \"姓名\": \"ss\" } }, \"script\":{ \"source\": \"\"\" if(ctx._source[\"年纪\"]\u003c34){ ctx.op = 'delete' } \"\"\" } } ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:3","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#查询并修改"},{"categories":["技术"],"content":" 删除// 删除文档 DELETE vdong/_doc/1002 // 删除索引 DELETE vdong // 根据搜索删除 POST vdong/_delete_by_query { \"query\": { \"term\": { \"realname\": { \"value\": \"dong\" } } } } ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:4","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#删除"},{"categories":["技术"],"content":" 批量操作// 创建索引 index 总会成功，如果 _id 已经存在，则更新数据 POST _bulk { \"index\" : { \"_index\" : \"vdong\", \"_id\" : \"1\" } } { \"name\" : \"小明\", \"sex\" : \"男\", \"age\" : \"18\" } { \"index\" : { \"_index\" : \"vdong\", \"_id\" : \"2\" } } { \"name\" : \"小红\", \"sex\" : \"女\", \"age\" : \"20\" } // 创建索引 create ，如果 _id 存在，该条不会成功 POST _bulk { \"create\" : { \"_index\" : \"vdong\", \"_id\" : \"2\" } } { \"name\" : \"小明\", \"sex\" : \"男\", \"age\" : \"18\" } { \"create\" : { \"_index\" : \"vdong\", \"_id\" : \"20\" } } { \"name\" : \"小红\", \"sex\" : \"女\", \"age\" : \"20\" } // 删除 { \"delete\" : { \"_index\" : \"vdong\", \"_id\" : \"2\" } } // 更新 { \"update\" : {\"_id\" : \"1\", \"_index\" : \"vdong\"} } { \"doc\" : {\"field2\" : \"value2\"} } 批量相关文档 ","date":"2021-11-04","objectID":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/:2:5","series":null,"tags":["es"],"title":"Es 索引相关","uri":"/posts/elastic/es%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/#批量操作"},{"categories":["技术"],"content":" 集群（cluster）由一个名称标识（ elisticsearch.yml 中 cluster.name: “docker-cluster” ），由一个或多个节点（node）组成。 # 查看集群状态 GET _cluster/state ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:0","series":null,"tags":["es"],"title":"Es 基本概念","uri":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#集群cluster"},{"categories":["技术"],"content":" 节点 （node）默认情况下，群集中的每个节点都可以处理 HTTP 和 Transport 流量。 Transport 层专门用于节点之间的通信。 HTTP 层由 REST 客户端使用。 所有节点都知道集群中的所有其他节点，并且可以将客户端请求转发到适当的节点。 根据作用分类： master-eligible node：主节点，管理集群，去中心化，避免单点故障，自动选举 data node ： 数据节点，保存和操作数据，如CRUD、搜索和聚合 ingest node ：数据接入节点。 角色为 ingest。 remote-eligible node ：远程合格节点。角色为 remote_cluster_client ，可以充当远程客户端。 Machine learning node ： 机器学习节点。 transform node ：转换节点。 Coordnating node 协调节点 搜索请求或批量索引请求等请求可能涉及保存在不同数据节点上的数据。 例如，搜索请求在两个阶段中执行，这两个阶段由接收客户请求的节点（即协调节点）协调。 在分散阶段，协调节点将请求转发到保存数据的数据节点。 每个数据节点在本地执行该请求，并将其结果返回到协调节点。 在收集阶段，协调节点将每个数据节点的结果缩减为单个全局结果集。 每个节点都隐式地是一个协调节点。 这意味着通过 node.roles 具有明确的空角色列表的节点将仅充当协调节点，无法禁用。 结果，这样的节点需要具有足够的内存和 CPU 才能处理收集阶段。协调节点的定义为： node.roles: [] 角色： master data data_content data_hot data_warm data_cold data_frozen ingest ml remote_cluster_client transform ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:0","series":null,"tags":["es"],"title":"Es 基本概念","uri":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#节点-node"},{"categories":["技术"],"content":" 索引（index）对应关系型数据库里的 databse 概念（但不完全相同）。一个集群，可以有多个索引。是一个逻辑名称。 索引是文档（对应关系数据库的 record ）的集合。 ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:0","series":null,"tags":["es"],"title":"Es 基本概念","uri":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#索引index"},{"categories":["技术"],"content":" 分片 （shard）分布式的搜索引擎，索引通常被拆分为多份，这份就叫分片（shard），分布在多个节点上。es 自动管理和平衡这些分片。 因此一个索引可以存储，超过单节点硬件限制的数据。 优点： 方便水平拓展 多节点并行操作（潜在地），提高吞吐 分片的类型： primary shard ：每个文档都有一个 primary shard 。 索引文档时，它首先在 Primary shard 上编制索引，然后在此分片的所有副本上（replica）编制索引。索引可以包含一个或多个主分片。 此数字确定索引相对于索引数据大小的可伸缩性。 创建索引后，无法更改索引中的主分片数。 replica shard：每个主分片可以具有零个或多个副本分片。数量可以动态修改（默认1个）。有两个目的： 1.增加故障转移：如果主要故障，可以将副本分片提升为主分片。即使你失去了一个 node，那么副本分片还是拥有所有的数据。 2.提高性能：get 和 search 请求可以由主 shard 或副本 shard 处理。 主分片 和 副本分片 的区别：只有主分片可以接受索引请求。副本分片和主分片都可以提供查询请求。 shard 健康状态 红色：集群中至少有一个主分片未分配 黄色：已分配所有主分片，但至少一个副分片未分配 绿色：分配所有分片 ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:0","series":null,"tags":["es"],"title":"Es 基本概念","uri":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#分片-shard"},{"categories":["技术"],"content":" 文档 （document）es 索引或搜索的最小数据单元是文档，对应关系数据库的 record。 特点： 独立 可以嵌套的 schemaless 不需要预先定义模式，可以动态调整 文档通常是数据的 JSON 表示形式。JSON over HTTP 是与 Elasticsearch 进行通信的最广泛使用的方式。 ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:5:0","series":null,"tags":["es"],"title":"Es 基本概念","uri":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#文档-document"},{"categories":["技术"],"content":" 相互关系每个 Index 由一个或许多的 documents 组成，并且这些 documents 可以分布于不同的 shard 之中，一个 node 里可以放零个或多个 shard （取决与 node 的种类），一个或多个节点（node）组成集群。 如：一个 index 有5个 shard 及1个 replica 这些 shard 分布于不同的物理机器上 ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:6:0","series":null,"tags":["es"],"title":"Es 基本概念","uri":"/posts/elastic/es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#相互关系"},{"categories":["技术"],"content":" Elasticsearch# 安装 docker pull elasticsearch:7.14.0 docker network create elk_net # 指定内存运行 docker run -d -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -h elasticsearch --name elasticsearch --net elk_net -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.14.0 # 访问 http://localhost:9200 or http://host-ip:9200 head 插件（可选） docker pull mobz/elasticsearch-head:5 docker run -d -p 9100:9100 docker.io/mobz/elasticsearch-head:5 # 访问 http://localhost:9100 or http://host-ip:9100 # 跨域问题 # 进入 elasticsearch 容器内部，修改配置文件 ./config/elasticsearch.yml # 增加 http.cors.enabled: true http.cors.allow-origin: \"*\" # 重启 docker restart elasticsearch # ElasticSearch-head 查询报 406错误码 # {\"error\":\"Content-Type header [application/x-www-form-urlencoded] is not supported\",\"status\":406} # _site 目录下 sed -i '6886c contentType: \"application/json;charset=UTF-8\",' vendor.js sed -i '7573c var inspectData = s.contentType === \"application/json;charset=UTF-8\" \u0026\u0026' vendor.js ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%AE%89%E8%A3%85/:1:0","series":null,"tags":["es"],"title":"Es 安装","uri":"/posts/elastic/es%E5%AE%89%E8%A3%85/#elasticsearch"},{"categories":["技术"],"content":" Kibanadocker pull kibana:7.14.0 docker run -d -h kibana --name kibana --net elk_net -p 5601:5601 kibana:7.14.0 # 访问 http://localhost:5601 or http://host-ip:5601 ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%AE%89%E8%A3%85/:2:0","series":null,"tags":["es"],"title":"Es 安装","uri":"/posts/elastic/es%E5%AE%89%E8%A3%85/#kibana"},{"categories":["技术"],"content":" Logstashdocker pull logstash:7.14.0 1. 编辑文件 logstash.conf 文件 docker run -h logstash --name logstash --network elk_net -it --rm -v /usr/local/logstash/config/pipeline:/usr/local/logstash/config/pipeline logstash:7.14.0 -f /usr/local/logstash/config/pipeline/logstash.conf ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%AE%89%E8%A3%85/:3:0","series":null,"tags":["es"],"title":"Es 安装","uri":"/posts/elastic/es%E5%AE%89%E8%A3%85/#logstash"},{"categories":["技术"],"content":" 网络问题docker network create elk_net // 将运行中的 容器 containerName 连接到网络 networkName 中 docker network connect networkName containerName // 将容器移除网络 docker network disconnect networkName containerName ","date":"2021-11-04","objectID":"/posts/elastic/es%E5%AE%89%E8%A3%85/:4:0","series":null,"tags":["es"],"title":"Es 安装","uri":"/posts/elastic/es%E5%AE%89%E8%A3%85/#网络问题"},{"categories":["技术"],"content":"这是一个静态 bolg 网站。 记录搭建过程。 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#"},{"categories":["技术"],"content":" 技术栈：hugo , git , github 。 hugo：是一个开源的 web 框架，使用 go 语言开发，可以将 markdown 文件快速的建构成静态网站。 git: 作为版本管理工具。 github: 作为代码仓库，使用 github 的 actions 做自动的建构和部署，分别部署在 github pages 和 阿里云上。 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#技术栈"},{"categories":["技术"],"content":" 搭建过程","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#搭建过程"},{"categories":["技术"],"content":" 本地安装 hugo不同操作系统安装差异略有不同，具体请参考：安装文档 本人使用如下命令安装 # Hugo extended 支持 Sass/SCSS scoop install hugo-extended ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:1","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#本地安装-hugo"},{"categories":["技术"],"content":" 创建站点，测试参考快速开始创建站点，并测试。 本人选择的主题是 Doit，并作简单配置（修改 config.toml 文件）即可，先跑起来。 至此博客已经搭建完成，你可以添加内容，在本地浏览博客，生成静态文件（默认 public/ 目录下），上传 public/ 目录的下的内容到服务器，就是一个静态的bolg 网站。 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:2","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#创建站点测试"},{"categories":["技术"],"content":" 添加版本管理本地：进入站点目录，git init 将该目录变成一个仓库；之后正常做版本管理。 github线上: 创建仓库，推荐命名 USER_NAME.github.io （之后设置 github pages 时，网址没有路径）。推送站点仓库到 github 。 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:3","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#添加版本管理"},{"categories":["技术"],"content":" 配置持续集成使用 github actions ，自动建构 hugo 并发布到 github pages 和 第三方服务器。 github actions ： 是一些持续集成的操作，包括但不局限于：抓取代码、运行测试、登录远程服务器，发布到第三方服务等。github 允许开发者，把每个操作协程独立的脚本，存放到代码仓库，供他人调用。官方市场，awesome-actions github pages ：是一个静态网址托管服务，github 允许你为你的每一个仓库，制作一个静态网页。 配置 github actions你可以在 actions 选项卡内新建 workflow ；也可以在项目根目录手动创建.github\\workflows\\XXX.yml 然后提交， action 的配置文件叫做 workflow 文件。 以 .yml 为后缀。 name: Hugo build and deploy on: # 当 main 分支被 push 时，此 workflow 被触发 push: branches: [ main ] # 允许你在 actions 选项卡中手动执行此 workflow workflow_dispatch: jobs: Hugo-build-deploy: runs-on: ubuntu-latest # 基于 ubuntu 最新版 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 # 检出代码 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo # 安装 hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build # 建构 hugo run: hugo --minify - name: Deploy Github Pages # 部署到 github pages uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public - name: 📂 Sync files # ftp 同步到 第三方服务器，如无第三方服务器可以省略此步。 uses: SamKirkland/FTP-Deploy-Action@4.1.0 with: server: ${{ secrets.FTP_URL }} username: ${{ secrets.FTP_USER }} password: ${{ secrets.FTP_PWD }} local-dir: ./public/ ps: 敏感字段需要在 Settings/Secrets 选项卡中设置，如上的 ${{ secrets.FTP_PWD }} 等。 ps：可以在 actions 选项卡中查看 action 运行状态，并调试错误。 配置 github pages当以上 actions 成功运行一次后（push 操作后，或 手动运行），你会发现多了一个 gh-pages 分支。 进入选项卡 Settings/Pages 配置 source ，branch 为 gh-pages，目录为 /(root)。 成功后会提示你 Your site is published at https://sunvdong.github.io/ （如果你的仓库名是 你的用户名.github.io，则网址后没有路径）。 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:4","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#配置持续集成"},{"categories":["技术"],"content":" 配置持续集成使用 github actions ，自动建构 hugo 并发布到 github pages 和 第三方服务器。 github actions ： 是一些持续集成的操作，包括但不局限于：抓取代码、运行测试、登录远程服务器，发布到第三方服务等。github 允许开发者，把每个操作协程独立的脚本，存放到代码仓库，供他人调用。官方市场，awesome-actions github pages ：是一个静态网址托管服务，github 允许你为你的每一个仓库，制作一个静态网页。 配置 github actions你可以在 actions 选项卡内新建 workflow ；也可以在项目根目录手动创建.github\\workflows\\XXX.yml 然后提交， action 的配置文件叫做 workflow 文件。 以 .yml 为后缀。 name: Hugo build and deploy on: # 当 main 分支被 push 时，此 workflow 被触发 push: branches: [ main ] # 允许你在 actions 选项卡中手动执行此 workflow workflow_dispatch: jobs: Hugo-build-deploy: runs-on: ubuntu-latest # 基于 ubuntu 最新版 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 # 检出代码 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo # 安装 hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build # 建构 hugo run: hugo --minify - name: Deploy Github Pages # 部署到 github pages uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public - name: 📂 Sync files # ftp 同步到 第三方服务器，如无第三方服务器可以省略此步。 uses: SamKirkland/FTP-Deploy-Action@4.1.0 with: server: ${{ secrets.FTP_URL }} username: ${{ secrets.FTP_USER }} password: ${{ secrets.FTP_PWD }} local-dir: ./public/ ps: 敏感字段需要在 Settings/Secrets 选项卡中设置，如上的 ${{ secrets.FTP_PWD }} 等。 ps：可以在 actions 选项卡中查看 action 运行状态，并调试错误。 配置 github pages当以上 actions 成功运行一次后（push 操作后，或 手动运行），你会发现多了一个 gh-pages 分支。 进入选项卡 Settings/Pages 配置 source ，branch 为 gh-pages，目录为 /(root)。 成功后会提示你 Your site is published at https://sunvdong.github.io/ （如果你的仓库名是 你的用户名.github.io，则网址后没有路径）。 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:4","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#配置-github-actions"},{"categories":["技术"],"content":" 配置持续集成使用 github actions ，自动建构 hugo 并发布到 github pages 和 第三方服务器。 github actions ： 是一些持续集成的操作，包括但不局限于：抓取代码、运行测试、登录远程服务器，发布到第三方服务等。github 允许开发者，把每个操作协程独立的脚本，存放到代码仓库，供他人调用。官方市场，awesome-actions github pages ：是一个静态网址托管服务，github 允许你为你的每一个仓库，制作一个静态网页。 配置 github actions你可以在 actions 选项卡内新建 workflow ；也可以在项目根目录手动创建.github\\workflows\\XXX.yml 然后提交， action 的配置文件叫做 workflow 文件。 以 .yml 为后缀。 name: Hugo build and deploy on: # 当 main 分支被 push 时，此 workflow 被触发 push: branches: [ main ] # 允许你在 actions 选项卡中手动执行此 workflow workflow_dispatch: jobs: Hugo-build-deploy: runs-on: ubuntu-latest # 基于 ubuntu 最新版 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 # 检出代码 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo # 安装 hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build # 建构 hugo run: hugo --minify - name: Deploy Github Pages # 部署到 github pages uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public - name: 📂 Sync files # ftp 同步到 第三方服务器，如无第三方服务器可以省略此步。 uses: SamKirkland/FTP-Deploy-Action@4.1.0 with: server: ${{ secrets.FTP_URL }} username: ${{ secrets.FTP_USER }} password: ${{ secrets.FTP_PWD }} local-dir: ./public/ ps: 敏感字段需要在 Settings/Secrets 选项卡中设置，如上的 ${{ secrets.FTP_PWD }} 等。 ps：可以在 actions 选项卡中查看 action 运行状态，并调试错误。 配置 github pages当以上 actions 成功运行一次后（push 操作后，或 手动运行），你会发现多了一个 gh-pages 分支。 进入选项卡 Settings/Pages 配置 source ，branch 为 gh-pages，目录为 /(root)。 成功后会提示你 Your site is published at https://sunvdong.github.io/ （如果你的仓库名是 你的用户名.github.io，则网址后没有路径）。 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:4","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#配置-github-pages"},{"categories":["技术"],"content":" 成果源码：https://github.com/SunVdong/sunvdong.github.io 博客地址: https://www.vdong.xyz or https://sunvdong.github.io ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#成果"},{"categories":["技术"],"content":" 参考Hugo官网 GitHub Actions 入门教程 使用 Hugo + Github 搭建个人博客 ","date":"2021-11-03","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:4:0","series":null,"tags":["hugo","折腾"],"title":"博客搭建记录","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#参考"},{"categories":["生活"],"content":"Hello world! ","date":"2021-11-01","objectID":"/posts/hello-world/:0:0","series":null,"tags":["日常","折腾"],"title":"Hello world","uri":"/posts/hello-world/#"}]