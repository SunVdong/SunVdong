<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Function-Method-Interface-of-Golang - vdong.xyz</title><meta name=Description content><meta property="og:title" content="Function-Method-Interface-of-Golang"><meta property="og:description" content="Go 语言中方法分为 具名和匿名，当匿名函数引用了外部变量时候就成了闭包函数。 方法是绑定到一个具体类型的特殊函数，方法依托类型。必须在编译时静态绑"><meta property="og:type" content="article"><meta property="og:url" content="https://www.vdong.xyz/posts/golang/function-method-interface-of-golang/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-09T15:22:58+08:00"><meta property="article:modified_time" content="2022-09-19T17:50:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Function-Method-Interface-of-Golang"><meta name=twitter:description content="Go 语言中方法分为 具名和匿名，当匿名函数引用了外部变量时候就成了闭包函数。 方法是绑定到一个具体类型的特殊函数，方法依托类型。必须在编译时静态绑"><meta name=application-name content="vdong.xyz"><meta name=apple-mobile-web-app-title content="vdong.xyz"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://www.vdong.xyz/posts/golang/function-method-interface-of-golang/><link rel=prev href=https://www.vdong.xyz/posts/golang/array-string-slice-of-golang/><link rel=next href=https://www.vdong.xyz/posts/unixs/rsyslog-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97/><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Function-Method-Interface-of-Golang","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.vdong.xyz\/posts\/golang\/function-method-interface-of-golang\/"},"genre":"posts","keywords":"golang","wordcount":2741,"url":"https:\/\/www.vdong.xyz\/posts\/golang\/function-method-interface-of-golang\/","datePublished":"2022-09-09T15:22:58+08:00","dateModified":"2022-09-19T17:50:50+08:00","publisher":{"@type":"Organization","name":"vdong"},"author":{"@type":"Person","name":"vdong"},"description":""}</script><script src=//instant.page/5.2.0 defer type=module integrity=sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z></script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else""==="light"||""==="dark"||""==="black"?(setTheme(""),saveTheme("")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=vdong.xyz>vdong.xyz</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=vdong.xyz>vdong.xyz</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#函数>函数</a></li><li><a href=#方法>方法</a></li><li><a href=#接口>接口</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Function-Method-Interface-of-Golang</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class="author fas fa-user-circle fa-fw"></span><a href=/ title=Author rel=author class=author>vdong</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/%E6%8A%80%E6%9C%AF/><i class="far fa-folder fa-fw"></i>技术</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-09-09>2022-09-09</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-09-19>2022-09-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2741 字&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;<span id=/posts/golang/function-method-interface-of-golang/ class=leancloud_visitors data-flag-title=Function-Method-Interface-of-Golang>
<i class="far fa-eye fa-fw"></i>&nbsp;<span class="leancloud-visitors-count waline-pageview-count" data-path=/posts/golang/function-method-interface-of-golang/></span>&nbsp;次阅读
</span>&nbsp;<span id=/posts/golang/function-method-interface-of-golang/ class=comment_count data-flag-title=Function-Method-Interface-of-Golang>
<i class="far fa-comments fa-fw"></i>&nbsp;<span class=waline-comment-count id=waline-comment-count data-path=/posts/golang/function-method-interface-of-golang/></span>&nbsp;条评论
</span>&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#函数>函数</a></li><li><a href=#方法>方法</a></li><li><a href=#接口>接口</a></li></ul></nav></div></div><div class=content id=content><p>Go 语言中方法分为 具名和匿名，当匿名函数引用了外部变量时候就成了闭包函数。</p><p>方法是绑定到一个具体类型的特殊函数，方法依托类型。必须在编译时静态绑定。</p><p>接口定义了方法的集合，这些方法依托于运行时的对象（实现了接口中的方法），因此接口对应的方法是运行时动态绑定的。</p><p>Go 语言程序的初始化和执行化总是从 <code>main.main</code> 开始。如果 <code>main</code> 导入了其他包，则按顺序将他们包含进来，一直递归；包含时，先创建和初始化包的常量、变量，然后调用包中的 <code>init</code> 函数。如下：</p><p><figure><a class=lightgallery href=/imgs/function-method-interface-of-golang/image-20220909154914868.png title=image-20220909154914868 data-thumbnail=/imgs/function-method-interface-of-golang/image-20220909154914868.png><img loading=lazy src=/imgs/function-method-interface-of-golang/image-20220909154914868.png srcset="/imgs/function-method-interface-of-golang/image-20220909154914868.png, /imgs/function-method-interface-of-golang/image-20220909154914868.png 1.5x, /imgs/function-method-interface-of-golang/image-20220909154914868.png 2x" sizes=auto alt=image-20220909154914868></a></figure></p><p>要注意的是，在 <code>main.main</code> 函数执行之前所有代码都运行在同一个 <code>Goroutine</code> 中，也是运行在程序的主系统线程中。如果某个 <code>init</code> 函数内部用 go 关键字启动了新的 <code>Goroutine</code> 的话，新的 <code>Goroutine</code> 和 <code>main.main</code> 函数是并发执行的。</p><h2 id=函数 class=headerLink><a href=#%e5%87%bd%e6%95%b0 class=header-mark></a>函数</h2><p>Go 语言中函数可以有<strong>多个</strong>返回值。</p><p><strong>参数</strong>和<strong>返回值</strong>都是以<strong>值</strong>的形式和被调用者交换数据的。</p><p>函数支持<strong>可变数量</strong>的参数，可变数量的参数必须是最后一个。可变数量的参数其实是一个切片类型的参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Swap</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>b</span><span class=p>,</span><span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sum</span><span class=p>(</span><span class=nx>a</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>more</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span><span class=k>range</span> <span class=nx>more</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>a</span> <span class=o>+=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>函数的返回值也可以用名字：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Find</span><span class=p>(</span><span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>key</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>value</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=p>=</span> <span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>derfer</code> 可以在 <code>reurn</code> 之后修改返回值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Inc</span><span class=p>()</span> <span class=p>(</span><span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>(){</span> <span class=nx>v</span><span class=o>++</span> <span class=p>}</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Go 语言中，函数传参是<strong>传值</strong>，只是针对了数据结构中固定部分传值。如：字符串或切片传参时，只是复制了对应数据结构中的指针、字符串长度、切片容量等值，并不包含指针指向的内容。可以将字符串和切片类型的参数转换为 <code>reflect.StringHeader</code> <code>reflect.SliceHeader</code>的结构体，可以更好的理解传值的含义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>twice</span><span class=p>(</span><span class=nx>x</span> <span class=p>[]</span><span class=kt>int</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>x</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>*=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>IntSliceHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Len</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Cap</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>twice</span><span class=p>(</span><span class=nx>x</span> <span class=nx>IntSliceHeader</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>x</span><span class=p>.</span><span class=nx>Len</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span><span class=p>.</span><span class=nx>Data</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>*=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如上，切片中的<strong>底层数组部分</strong>是通过<strong>隐式指针传递</strong>(<strong>指针</strong>本身依然是<strong>传值</strong>的，但是指针指向的却是同一份的内存数据)，所以被调用函数是可以通过<strong>修改指针指向的数据</strong>（指针本身的指向并没有发生变化），从而达到修改掉调用参数切片中数据的效果。</p><p>Go 语言支持递归调用，且调用深度逻辑上没有限制，函数调用栈不会出现溢出错误，这是因为 Go 语言运行时会根据需要动态调整函数栈的大小。栈最大可达到GB级。</p><p>Go 1.4 之前，动态栈采用的时分段式的动态栈，通俗说就是采用一个链表实现动态栈。链表节点位置不变，缺点: 跨节点地址位置不是一定是连续的，CPU缓存命中率低。</p><p>Go 1.4 之后改用连续的动态栈实现，通俗来说是采用一个类似动态数组来实现栈。缺点：当连续栈需要动态增长时候，需要重新分配内存空间并复制数据到新的空间，这导致了栈中之前变量的地址发生变化（Go 的运行时会自动更新这些变化）。但是这意味着 ，Go 语言中的指针不是固定不变的，不能随意将指针保存在数值变量中，不能将 Go 语言的地址随意保存到非 GC 的环境中（如：使用 CGO 时，C 语言不能长期持有 Go 与语言的地址）。</p><p>Go 语言隐藏了堆栈的细节，编译器和运行时帮我们做了还多工作，以下代码在 C/C++ 中不可行的，但在 Go 语言中并没问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 如果参数变量在栈上的话，函数返回之后栈变量就失效了，返回的地址自然也应该失效了
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 内部虽然调用 new 函数创建了 *int 类型的指针对象，但是依然不知道它具体保存在哪里
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>g</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>需要注意的是：不要假设变量在内存中的位置是固定不变的，指针随时可能会变化，特别是在你不期望它变化的时候。</p><h2 id=方法 class=headerLink><a href=#%e6%96%b9%e6%b3%95 class=header-mark></a>方法</h2><p>Go 语言方法关联到结构体上，在编译阶段完成静态绑定。</p><p>我们可以给任意自定义的结构体添加一个或多个方法。方法和结构体定义必须在同一个包里。</p><p>其实，方法是由函数演化而来，只是将函数的第一个对象参数移动到函数名前面而已。因此我们可以使用方法表达式的特性将方法还原为普通类型函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// func ReadFile(f *File, offset int64, data []byte) int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>ReadFile</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>File</span><span class=p>).</span><span class=nx>Read</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// func CloseFile(f *File) error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>CloseFile</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>File</span><span class=p>).</span><span class=nx>Close</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>f</span><span class=p>,</span> <span class=nx>_</span><span class=o>:=</span> <span class=nf>OpenFile</span><span class=p>(</span><span class=s>&#34;foo.txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>CloseFile</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span></code></pre></div><p>对于有些场景，我们并不关心具体操作对象的类型，只要满足通用的 行为 就可以了。在Go语言中，我们可以通过闭包做参数绑定，从而消除上边函数参数类型的的限制：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>f</span><span class=p>,</span> <span class=nx>_</span><span class=o>:=</span><span class=nf>OpenFile</span><span class=p>(</span><span class=s>&#34;foo.txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 绑定了 f 对象
</span></span></span><span class=line><span class=cl><span class=c1>// func Close() error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>Close</span> <span class=p>=</span> <span class=kd>func</span><span class=p>()</span> <span class=nf>err</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=nx>File</span><span class=p>).</span><span class=nf>Close</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 绑定到了 f 对象
</span></span></span><span class=line><span class=cl><span class=c1>// func Read(offset int64, data []byte) int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>Read</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>offset</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=nx>File</span><span class=p>).</span><span class=nf>Read</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span> <span class=nx>offset</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 文件处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>Read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 使用方法值简化以上问题：
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 方法值: 绑定到了 f 对象
</span></span></span><span class=line><span class=cl><span class=c1>// func Close() error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>Close</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>Close</span>
</span></span><span class=line><span class=cl><span class=c1>// 方法值: 绑定到了 f 对象
</span></span></span><span class=line><span class=cl><span class=c1>// func Read(offset int64, data []byte) int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>Read</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>Read</span>
</span></span><span class=line><span class=cl><span class=c1>// 文件处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>Read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>Close</span><span class=p>()</span>
</span></span></code></pre></div><p>Go语言使用组合的方式支持继承。使用结构体中的匿名成员来实现继承。因此<strong>继承来的方法的接收者参数依然是匿名成员自身，而不是当前变量</strong>。</p><p>传统继承，子类的方法是运行时动态绑定到对象的，<code>this</code> 可能不是集类类型对应的对象，不确定性。</p><p>Go语言继承，子类方法是编译时静态绑定的，<code>this</code> 就是实现该方法的类型对象，确定性。</p><h2 id=接口 class=headerLink><a href=#%e6%8e%a5%e5%8f%a3 class=header-mark></a>接口</h2><p>Go 语言的接口满足隐式的鸭子类型。即：走路看着像鸭子，叫起来也像鸭子的，就可以当作鸭子。go语言中，一个对象只要看起来像是某个接口的实现，那么就可以把他作为该接口使用。</p><p>这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不用去破坏这些类型原有的定义。</p><p>Go语言的接口类型是延迟绑定的，可以实现虚函数的多态功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// fmt.Fprintf 签名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// io.Writer 是用于输出的接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们可以定制自己的输出对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>UpperWrite</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>UppperWriter</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>ToUpper</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果满足 <code>fmt.Stringer</code> 接口，则默认使用对象的 <code>String</code> 方法的返回结构打印：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>UpperString</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>UpperString</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>ToUpper</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于基础类型（非接口），go 不支持隐式的类型转换，例如我们无法将一个 <code>int</code> 类型直接赋值给 <code>int64</code>类型的变量。</p><p>对于接口类型，可以隐式转换，对象和接口，接口和接口都可以转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ReadCloser</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>os</span><span class=p>.</span><span class=nx>File</span><span class=p>)(</span><span class=nx>f</span><span class=p>)</span> <span class=c1>// 隐式转换, *os.File 满足 io.ReadCloser 接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>b</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span>     <span class=p>=</span> <span class=nx>a</span>             <span class=c1>// 隐式转换, io.ReadCloser 满足 io.Reader 接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Closer</span>     <span class=p>=</span> <span class=nx>a</span>             <span class=c1>// 隐式转换, io.ReadCloser 满足 io.Closer 接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>d</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span>     <span class=p>=</span> <span class=nx>c</span><span class=p>.(</span><span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=c1>// 显式转换, io.Closer 不满足 io.Reader 接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></div><p>防止这种对象和接口太灵活的方式：</p><ol><li><p>包含特殊方法，来区分接口。(君子协定)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>Error</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=c1>// RuntimeError 方法 用于避免其它类型无意中适配了该接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>RuntimeError</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>proto</span><span class=p>.</span><span class=nx>Message</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Reset</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 用于避免其它类型无意中适配了该接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ProtoMessage</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这是可以伪造的。</p></li><li><p>更严格一点，可以定义一个私有方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>testing</span><span class=p>.</span><span class=nx>TB</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Error</span><span class=p>(</span><span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=nf>Errorf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// A private method to prevent users implementing the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// interface and so future additions to it will not
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// violate Go 1 compatibility.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>private</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这是有代价的：</p><ol><li><p>这个接口只能内部使用。</p></li><li><p>这种防护也不是绝对的。（可以在结构体中嵌入匿名类型的成员来绕过）。</p><p>我们在自己的 <code>TB</code> 结构体类型中重新实现了 <code>Fatal</code> 方法，然后通过将对象隐式转换为 <code>testing.TB</code> 接口类型（因为内嵌了匿名的 <code>testing.TB</code> 对象，因此是满足 <code>testing.TB</code> 接口的），然后通过 <code>testing.TB</code> 接口来调用我们自己的 <code>Fatal</code> 方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TB</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>testing</span><span class=p>.</span><span class=nx>TB</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>TB</span><span class=p>)</span> <span class=nf>Fatal</span><span class=p>(</span><span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;TB.Fatal disabled!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>tb</span> <span class=nx>testing</span><span class=p>.</span><span class=nx>TB</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>TB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>tb</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;Hello, playground&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这种通过嵌入匿名接口或嵌入匿名指针对象来实现继承的做法其实是一种纯虚继承，我们继承的只是接口指定的规范，真正的实现在运行的时候才被注入。比如，我们可以模拟实现一个gRPC的插件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>grpcPlugin</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>generator</span><span class=p>.</span><span class=nx>Generator</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>grpcPlugin</span><span class=p>)</span> <span class=nf>Name</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;grpc&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>grpcPlugin</span><span class=p>)</span> <span class=nf>Init</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>generator</span><span class=p>.</span><span class=nx>Generator</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>p</span><span class=p>.</span><span class=nx>Generator</span> <span class=p>=</span> <span class=nx>g</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>grpcPlugin</span><span class=p>)</span> <span class=nf>GenerateImports</span><span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>generator</span><span class=p>.</span><span class=nx>FileDescriptor</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>file</span><span class=p>.</span><span class=nx>Service</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>p</span><span class=p>.</span><span class=nf>P</span><span class=p>(</span><span class=s>`import &#34;google.golang.org/grpc&#34;`</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>构建的对象必须满足 <a href=https://github.com/golang/protobuf/blob/master/protoc-gen-go/generator/generator.go target=_blank rel="noopener noreferrer">https://github.com/golang/protobuf/blob/master/protoc-gen-go/generator/generator.go</a> 中 <code>Plugin</code> 接口。</p><p>也就是说 <code>grpcPlugin</code> 类型的 <code>GenerateImports</code> 方法中使用的 <code>p.P(...)</code> 函数却是通过 <code>Init</code> 函数注入的 <code>generator.Generator</code> 对象实现（因为grpcPlugin 类型中比没有 P 方法，且只要一个成员）。</p></li></ol></li></ol><blockquote><p><a href=https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-04-func-method-interface.html target=_blank rel="noopener noreferrer">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-04-func-method-interface.html</a></p></blockquote></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-09-19</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/golang/>golang</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/golang/array-string-slice-of-golang/ class=prev rel=prev title="Golang 中的数组字符串和切片"><i class="fas fa-angle-left fa-fw"></i>Golang 中的数组字符串和切片</a>
<a href=/posts/unixs/rsyslog-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97/ class=next rel=next title=" rsyslog 发送和接收远程日志">rsyslog 发送和接收远程日志<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=waline class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://waline.js.org/>Waline</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.114.1">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer"></a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/waline/waline.min.css><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{waline:{comment:!0,copyright:!0,dark:"body[theme='dark'], body[theme='black']",el:"#waline",emoji:["https://i.whaoot.com/emojis/qq/"],lang:"zh-cn",pageview:!0,serverURL:"https://comment.vdong.xyz/"}},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1}}</script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/lib/waline/waline.js defer></script><script type=text/javascript src=/js/waline.min.js defer></script></div></body></html>