<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>数据流的类型 - 我的灵感记录</title><meta name=Description content><meta property="og:title" content="数据流的类型">
<meta property="og:description" content="数据在不共享内存的进程传递，就需要编码为字节序列。有多种方式。 兼容性 实际描述了 编码数据的进程 和 解码数据的进程 之间的关系。它对 可演化性（允许你"><meta property="og:type" content="article"><meta property="og:url" content="https://www.vdong.xyz/posts/ddia/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-07T10:59:06+08:00"><meta property="article:modified_time" content="2024-04-16T07:36:18+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据流的类型"><meta name=twitter:description content="数据在不共享内存的进程传递，就需要编码为字节序列。有多种方式。 兼容性 实际描述了 编码数据的进程 和 解码数据的进程 之间的关系。它对 可演化性（允许你"><meta name=application-name content="我的灵感记录"><meta name=apple-mobile-web-app-title content="我的灵感记录"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://www.vdong.xyz/posts/ddia/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B/><link rel=prev href=https://www.vdong.xyz/posts/ddia/%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F/><link rel=next href=https://www.vdong.xyz/posts/unixs/shell%E7%BC%96%E7%A8%8B-2/><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据流的类型","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.vdong.xyz\/posts\/ddia\/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B\/"},"genre":"posts","keywords":"数据密集, 数据流, dataflow, 不共享内存数据传递","wordcount":4651,"url":"https:\/\/www.vdong.xyz\/posts\/ddia\/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B\/","datePublished":"2023-09-07T10:59:06+08:00","dateModified":"2024-04-16T07:36:18+00:00","publisher":{"@type":"Organization","name":"vdong"},"author":{"@type":"Person","name":"vdong"},"description":""}</script><script src=//instant.page/5.2.0 defer type=module integrity=sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z></script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else""==="light"||""==="dark"||""==="black"?(setTheme(""),saveTheme("")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=我的灵感记录>我的灵感记录</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=我的灵感记录>我的灵感记录</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#数据库中的数据流>数据库中的数据流</a><ul><li><a href=#数据的生命周期超出代码的生命周期>数据的生命周期超出代码的生命周期</a></li><li><a href=#数据归档>数据归档</a></li></ul></li><li><a href=#服务中的数据流rest-与-rpc>服务中的数据流：REST 与 RPC</a><ul><li><a href=#web服务>Web服务</a></li><li><a href=#远程过程调用rpc的问题>远程过程调用（RPC）的问题</a></li><li><a href=#rpc-的当前方向>RPC 的当前方向</a></li></ul></li><li><a href=#消息传递中的数据流>消息传递中的数据流</a><ul><li><a href=#消息代理>消息代理</a></li><li><a href=#分布式-actor-框架>分布式 actor 框架</a></li></ul></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">数据流的类型</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class="author fas fa-user-circle fa-fw"></span><a href=/ title=Author rel=author class=author>vdong</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/%E6%8A%80%E6%9C%AF/><i class="far fa-folder fa-fw"></i>技术</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-09-07>2023-09-07</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2024-04-16>2024-04-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4651 字&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 10 分钟&nbsp;<span id=/posts/ddia/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B/ class=leancloud_visitors data-flag-title=数据流的类型>
<i class="far fa-eye fa-fw"></i>&nbsp;<span class="leancloud-visitors-count waline-pageview-count" data-path=/posts/ddia/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B/></span>&nbsp;次阅读
</span>&nbsp;<span id=/posts/ddia/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B/ class=comment_count data-flag-title=数据流的类型>
<i class="far fa-comments fa-fw"></i>&nbsp;<span class=waline-comment-count id=waline-comment-count data-path=/posts/ddia/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B/></span>&nbsp;条评论
</span>&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#数据库中的数据流>数据库中的数据流</a><ul><li><a href=#数据的生命周期超出代码的生命周期>数据的生命周期超出代码的生命周期</a></li><li><a href=#数据归档>数据归档</a></li></ul></li><li><a href=#服务中的数据流rest-与-rpc>服务中的数据流：REST 与 RPC</a><ul><li><a href=#web服务>Web服务</a></li><li><a href=#远程过程调用rpc的问题>远程过程调用（RPC）的问题</a></li><li><a href=#rpc-的当前方向>RPC 的当前方向</a></li></ul></li><li><a href=#消息传递中的数据流>消息传递中的数据流</a><ul><li><a href=#消息代理>消息代理</a></li><li><a href=#分布式-actor-框架>分布式 actor 框架</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>数据在不共享内存的进程传递，就需要编码为字节序列。有多种方式。</p><p><strong>兼容性</strong> 实际描述了 <strong>编码数据的进程</strong> 和 <strong>解码数据的进程</strong> 之间的关系。它对 <strong>可演化性</strong>（允许你升级系统的部分，而不必全部升级） 非常重要。</p><p>数据可以通过多种方式从一个流程流向另一个流程（通常先编码为字节序列，再解码）。谁编码，谁解码？以下是常见场景：</p><ul><li>数据库</li><li>服务调用</li><li>异步消息传递</li></ul><h2 id=数据库中的数据流 class=headerLink><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e6%b5%81 class=header-mark></a>数据库中的数据流</h2><p>写入数据 &mdash;> 编码数据；读取数据 &mdash; > 解码数据。</p><p>单进程连接数据库，现在写入的数据，未来才读取。<strong>向后兼容</strong> 是必须的。</p><p>多个进程更常见，可能是不同的应用程序或服务连接一个数据库，也可能是一个服务的几个实例（并行运行，并行的目的是可伸缩性和容错性）。在这个场景下，可能发生，一个数据库中的值被较新的代码写入，被旧代码读取。因此 数据库也需要 <strong>向前兼容</strong>。</p><p>当你向数据库新增了一个字段（即修改了数据库的表结构，或者说修改了数据的模式 schema ），较新的代码写入包含新字段内容的数据到数据库中，旧代码（不知道有新字段）在读取、更新、写回记录到数据库时，理想状态时需保值新字段的值不变。编码格式需要支持，在应用层面也需要小心。</p><h3 id=数据的生命周期超出代码的生命周期 class=headerLink><a href=#%e6%95%b0%e6%8d%ae%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%b6%85%e5%87%ba%e4%bb%a3%e7%a0%81%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f class=header-mark></a>数据的生命周期超出代码的生命周期</h3><p>代码的版本更新频繁，数据库的数据版本可能变化可能大多并不频繁。</p><p>将数据迁移到一个新的模式是昂贵的，大多数数据库尽可能避免它，大多数关系数据库（除了mysql，并非真的必要时，它也经常会重写整个表）允许一些简单的模式变更，如添加一个默认为空的新列，而非重写现有数据。 LinkedIn 的文档数据库 Espresso 使用 Avro 存储，允许它使用 Avro 的模式演变规则。</p><p>模式演变允许整个数据库看起来好像是用单个模式编码的，即使底层存储可能包含用各种历史版本的模式编码的记录。</p><h3 id=数据归档 class=headerLink><a href=#%e6%95%b0%e6%8d%ae%e5%bd%92%e6%a1%a3 class=header-mark></a>数据归档</h3><p>创建数据快照时，即使源数据库中的原始编码包含来自不同时代的模式版本的混合，数据转储通常也将使用最新模式进行编码。既然你不管怎样都要拷贝数据，那么你可以对这个数据拷贝进行一致的编码。</p><p>由于数据转储是一次写入的，而且以后是不可变的，所以 Avro 对象容器文件等格式非常适合。这也是一个很好的机会，可以将数据编码为面向分析的列式格式，例如 Parquet。</p><h2 id=服务中的数据流rest-与-rpc class=headerLink><a href=#%e6%9c%8d%e5%8a%a1%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e6%b5%81rest-%e4%b8%8e-rpc class=header-mark></a>服务中的数据流：REST 与 RPC</h2><p>当你需要通过网络在进程间通信时，有很多方法，最常见的是采用 cs 架构，即 服务端 通过网络暴露 API，客户端通过网络向服务端的 API 发出请求。 服务器公开的 API 被称为 <strong>服务</strong> 。</p><p>Web 是怎么工作的，客户端（即浏览器）想服务器发出请求，通过 GET 请求下载 HTML，CSS，JavaScript，图片等，通过 POST 请求发送数据给服务器。API 包含一组协议和数据格式（HTTP，URLs, SSL/TLS, HTML，等）。浏览器、web服务器，网站作者都同意这些标准。</p><p>除了浏览器，还有很多其他客户端，例如，移动端或电脑端的app，浏览器中的客户端 JavaScript 程序可以使用XMLHttpRequest成为客户端。</p><p>另外服务器本身也可以作为另一个服务的客户端（如 Web 应用服务器充当数据库的客户端）。这种方法通常用于将大型应用程序按照功能区域分解为较小的服务，这样当一个服务需要来自另一个服务的某些功能或数据时，就会向另一个服务发出请求。这种构建应用程序的方式传统上被称为 <strong>面向服务的体系结构</strong>（service-oriented architecture，SOA） ，最近被改进和更名为 <strong>微服务架构</strong> 。</p><p>服务类似于数据库，相同点，允许客户端提交和查询数据。不同之处，数据库允许使用特定的查询语言进行任意查询，但服务只公开了一个特定于应用程序的 API （只允许由服务业务逻辑预定义的输入和输出）。这种限制提
供了一定程度的封装：服务可以对客户可以做什么和不可以做什么施加细粒度的限制。</p><p>面向服务/微服务架构的一个关键设计目标是通过使服务独立部署和演化来使应用程序更易于更改和维护。例如，每个服务应该由一个团队拥有，并且该团队应该能够经常发布新版本的服务，而不必与其他团队协调。换句话说，我们应该期望服务器和客户端的旧版本和新版本同时运行，因此服务器和客户端使用的数据编码必须在不同版本的服务API之间兼容。</p><h3 id=web服务 class=headerLink><a href=#web%e6%9c%8d%e5%8a%a1 class=header-mark></a>Web服务</h3><p>当服务使用HTTP作为底层通信协议时，可称之为Web服务。不仅在Web上使用，还可以用于不同的环境中。如：</p><ol><li>客户端应用程序（移动设备上的app，使用Ajax的 JS 应用程序）通过 HTTP 像服务发出请求。通常通过公共互联网进行。</li><li>一种服务向同组织拥有的另一项服务提出请求，这些服务通常位于同一数据中心，作为面向服务/微型架构的一部分。（支持这种用例的软件有时被称为中间件）。</li><li>一种服务通过互连网向不同的组织所拥有的服务提出请求。用于不同组织后端系统之前的数据交换。如在线服务提供的公共 API，用户共享用户数据的OAuth 等。</li></ol><p>由两种流行的服务方法： REST 和 SOAP。</p><p>REST 不是一个协议，是基于HTTP原则的设计哲学。强调简单的数据格式，使用 URL 来标记资源，使用 HTTP 功能来进行缓存控制，身份验证和内容类型协商。根据 REST 原则设计的 API 称为 RESTful 。</p><p>SOAP是一种基于XML的用于发起网络API请求的协议。尽管它最常用于HTTP上，但它的目标是独立于HTTP，并避免使用大多数HTTP特性。</p><h3 id=远程过程调用rpc的问题 class=headerLink><a href=#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8rpc%e7%9a%84%e9%97%ae%e9%a2%98 class=header-mark></a>远程过程调用（RPC）的问题</h3><p>RPC模型试图向远程网络服务发出请求，看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为位置透明）。尽管RPC起初看起来很方便，但这种方法根本上是有缺陷的。网络请求与本地函数调用非常不同：</p><ul><li>本地函数可预测，成功或失败取决于参数。网络请求不可预知：网络问题，请求和响应可能丢失，远程计算机可能很慢或不可用，这些问题不在您的控制范围且常见，所以你必须预测并应对它们，比如重试失败的请求。</li><li>本地函数要么返回结果，要么抛出异常，或永远不返回（进入无限循环或进程崩溃）。网络请求可能由于超时不返回结果，如果你没有收到来自远程服务的响应，可能的原因有服务器出错，网络超时（请求未到达，响应未到达）。</li><li>调用本地功能，通常需要的时间是大致相同的。网络请求比本地函数调用慢的多，且延迟非常可变：不到一毫秒可以完成的请求，在网络拥塞或远程服务超载时，可能需要几秒钟。</li><li>调用本地函数时，可以高效地将引用（指针）传递给本地内存中的对象。当你发出一个网络请求时，所有这些参数都需要被编码成可以通过网络发送的一系列字节。对于字符串和数字没什么问题，但是对于较大的对象可能就会成为问题。</li></ul><p>客户端和服务可以用不同的编程语言实现，所以RPC框架必须将数据类型从一种语言翻译成另一种语言。这可能会捅出大篓子，因为不是所有的语言都具有相同的类型 。用单一语言编写的单个进程中不存在此问题。</p><p>所有这些因素意味着尝试使远程服务看起来像编程语言中的本地对象一样毫无意义，因为这是一个根本不同的事情。 REST的部分吸引力在于，它并不试图隐藏它是一个网络协议的事实（尽管这似乎并没有阻止人们在REST之上构建RPC库）。</p><h3 id=rpc-的当前方向 class=headerLink><a href=#rpc-%e7%9a%84%e5%bd%93%e5%89%8d%e6%96%b9%e5%90%91 class=header-mark></a>RPC 的当前方向</h3><p>尽管有这样那样的问题，RPC不会消失。有很多基于编码格式的RPC框架：Thrift和Avro带有RPC支持，gRPC是使用Protocol Buffers的RPC实现，Finagle也使用Thrift，Rest.li 使用 JSON over HTTP 。</p><p>这种新一代的RPC框架更加明确的是，远程请求与本地函数调用不同。Finagle和Rest.li 使用futures（promises）来封装可能失败的异步操作。 Futures 还可以简化需要并行发出多项服务的情况，并将其结果合并。gRPC支持流，其中一个调用不仅包括一个请求和一个响应，还包括一系列的请求和响应</p><p>其中一些框架还提供服务发现，即允许客户端找出在哪个IP地址和端口号上可以找到特定的服务。</p><p>使用二进制编码格式的自定义RPC协议可以实现比通用的JSON over REST更好的性能。但是，RESTful API还有其他一些显著的优点：</p><ul><li>实验和调试更友好（只需使用Web浏览器或命令行工具curl，无需任何代码生成或软件安装即可向其请求）</li><li>它受到所有主流编程语言和平台的支持，并且拥有庞大的工具生态系统（服务器、缓存、负载均衡器、代理、防火墙、监控、调试工具、测试工具等）可供使用。</li></ul><p>由于这些原因，REST 似乎是公共 API 的主要风格。 RPC框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一数据中心内。</p><h2 id=消息传递中的数据流 class=headerLink><a href=#%e6%b6%88%e6%81%af%e4%bc%a0%e9%80%92%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e6%b5%81 class=header-mark></a>消息传递中的数据流</h2><p>REST和RPC：其中一个进程通过网络向另一个进程发送请求并期望尽可能快的响应。</p><p>数据库：一个进程写入编码数据，另一个进程在将来再次读取。</p><p><strong>异步消息传输</strong> 是介于 RPC 和 数据库之间的 进程间通信方式。类似 RPC 客户端的请求（通常称为消息）以低延迟传送到另一个进程，类似于数据库，不是通过直接的网络连接发送消息，而是通过称为消息代理（也称为消息队列或面向消息的中间件）的中介来临时存储消息。</p><p>VS RPC的优点：</p><ul><li>接受端不可用或者过载时，充当缓冲区，可靠性++。</li><li>自动的重传消息到已经崩溃的进程，防止丢失。</li><li>避免发送方知道接收方的IP和端口（云部署环境中，虚拟机经常创建和销毁，比较有用）</li><li>允许一条消息发送给多个接受端。</li><li>发送端和接收端逻辑分离。</li></ul><p>消息传递通信通常是单向的，RPC是双向的。发送者通常不期望收到消息的回复。但是回复也是可以实现的，通常是在另外一个单独的通道（channel）上，这种模式叫作 <strong>异步</strong> 。</p><h3 id=消息代理 class=headerLink><a href=#%e6%b6%88%e6%81%af%e4%bb%a3%e7%90%86 class=header-mark></a>消息代理</h3><p>开源方案： RabbitMQ，ActiveMQ，HornetQ，NATS，Apache Kafka</p><p>消息代理的大致逻辑：</p><p>一个进程（称为生产者）将消息发送到一个被命名的队列或主题（topic），而消息代理（即经纪人）负责确保该消息被传递给订阅了该队列或主题的一个或多个消费者。</p><p>队列或主题（topic）是单向的。但是，消息的消费者可以将回复的消息发布到另一个主题或者原始消息发送者使用的回复队列（就类似与RPC了）。</p><p>消息代理通常不强制特定的数据模型——一个消息统称只是一个包含元数据的字节流。</p><h3 id=分布式-actor-框架 class=headerLink><a href=#%e5%88%86%e5%b8%83%e5%bc%8f-actor-%e6%a1%86%e6%9e%b6 class=header-mark></a>分布式 actor 框架</h3><p>actor 模型是单进程的并发模型。对比直接操作线程（线程存在的问题竞争条件，锁，死锁），逻辑被封装在 actor 中，每个 actor 代表一个客户和实体，它有一些本地状态（不与其他 actor 共享），通过发送和接受异步消息来与其他 actor 通信。消息传递不具有保障性，可能丢失。</p><p>在分布式的 Actor框架中，此模型用于跨多个节点伸缩应用程序。不管发送方和接收方是相同还是不同的节点，都是用相同的消息传递机制。如果它们位于不同的节点，消息则被透明编码为字节序列，通过网络发送，然后在另一侧解码。</p><p>在使用Actor模型时，由于该模型已经假设了消息可能会丢失，因此位置透明性效果更好（相比 RPC ）。即使在单个进程内部，Actor模型也能处理消息丢失的情况。尽管网络延迟可能比同一进程内部更高，但在使用Actor模型时，本地和远程通信之间的基本不匹配较少，这意味着在设计应用程序时，可以更容易地处理本地和远程通信之间的差异。</p><p>分布式的 Actor 框架实质上是将消息代理和 actor 编程模型集成到一个框架中。</p><p>三个流行的分布式 actor 框架处理消息编码如下：</p><ul><li>默认情况下，Akka 使用 Java 的内置序列化，不提供前向或后向兼容性。 但是，你可以用类似 Prototol Buffers 的东西替代它，从而获得滚动升级的能力。</li><li>Orleans 默认使用不支持滚动升级部署的自定义数据编码格式；要部署新版本的应用程序，你需要设置一个新的集群，将流量从旧集群迁移到新集群，然后关闭旧集群。 像 Akka 一样，可以使用自定义序列化插件。</li><li>在 Erlang OTP 中，对记录模式进行更改是非常困难的（尽管系统具有许多为高可用性设计的功能）。 滚动升级是可能的，但需要仔细计划。 一个新的实验性的 <code>maps</code> 数据类型（2014 年在 Erlang R17 中引入的类似于 JSON 的结构）可能使得这个数据类型在未来更容易。</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2024-04-16</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86/>数据密集</a>,&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/>数据流</a>,&nbsp;<a href=/tags/dataflow/>Dataflow</a>,&nbsp;<a href=/tags/%E4%B8%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/>不共享内存数据传递</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/ddia/%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F/ class=prev rel=prev title=编码数据的格式><i class="fas fa-angle-left fa-fw"></i>编码数据的格式</a>
<a href=/posts/unixs/shell%E7%BC%96%E7%A8%8B-2/ class=next rel=next title=Shell编程-2>Shell编程-2<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=waline class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://waline.js.org/>Waline</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.124.1">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer"></a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href=https://beian.miit.gov.cn/ target=_blank>豫ICP备18016268号-2</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/waline/waline.min.css><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{waline:{comment:!0,copyright:!0,dark:"body[theme='dark'], body[theme='black']",el:"#waline",emoji:["https://i.whaoot.com/emojis/qq/"],lang:"zh-cn",pageview:!0,serverURL:"https://comment.vdong.xyz/"}},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1}}</script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/lib/waline/waline.js defer></script><script type=text/javascript src=/js/waline.min.js defer></script></div></body></html>